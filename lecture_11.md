Лекция 11. Объектная модель Python
===


### Значки, используемые в тексте

* :clock2: &mdash; отмечает, что высказывание не совсем верно, но будет уточнено позднее.
* :star: &mdash; выделяет определение нового понятия.
* :exclamation: &mdash; привлекает внимание к высказыванию.
* :point_up: &mdash; указывает на небольшое отступление от темы или уточнение.
* :bulb: &mdash; индикатор традиций и договорённостей. 
* :warning: &mdash; требуется осторожность: возможно, сложное высказывание.  

# Содержание

* [Немного терминологии](#0J3QtdC80L3QvtCz0L4g0YLQtdGA0LzQuNC90L7Qu9C-0LPQuNC4)

    * [Вкратце об объектно-ориентированной парадигме](#0JLQutGA0LDRgtGG0LUg0L7QsSDQvtCx0YrQtdC60YLQvdC-LdC-0YDQuNC10L3RgtC40YDQvtCy0LDQvdC90L7QuSDQv9Cw0YDQsNC00LjQs9C80LU)

    * [Типы данных в ООП](#0KLQuNC_0Ysg0LTQsNC90L3Ri9GFINCyINCe0J7Qnw)

* [Типы и классы в Python](#0KLQuNC_0Ysg0Lgg0LrQu9Cw0YHRgdGLINCyIFB5dGhvbg)

    * [Всё вокруг -- объекты](#0JLRgdGRINCy0L7QutGA0YPQsyAtLSDQvtCx0YrQtdC60YLRiw)

    * [Типы](#0KLQuNC_0Ys)

    * [Классы](#0JrQu9Cw0YHRgdGL)

    * [Объекты класса](#0J7QsdGK0LXQutGC0Ysg0LrQu9Cw0YHRgdCw)

    * [Свойства, поля, атрибуты. Немного терминологии.](#0KHQstC-0LnRgdGC0LLQsCwg0L_QvtC70Y8sINCw0YLRgNC40LHRg9GC0YsuINCd0LXQvNC90L7Qs9C-INGC0LXRgNC80LjQvdC-0LvQvtCz0LjQuC4)

    * [Механизм доступа к свойствам объектов. Наследование свойств](#0JzQtdGF0LDQvdC40LfQvCDQtNC-0YHRgtGD0L_QsCDQuiDRgdCy0L7QudGB0YLQstCw0Lwg0L7QsdGK0LXQutGC0L7Qsi4g0J3QsNGB0LvQtdC00L7QstCw0L3QuNC1INGB0LLQvtC50YHRgtCy)

    * [Множественное наследование](#0JzQvdC-0LbQtdGB0YLQstC10L3QvdC-0LUg0L3QsNGB0LvQtdC00L7QstCw0L3QuNC1)


<a name="0J3QtdC80L3QvtCz0L4g0YLQtdGA0LzQuNC90L7Qu9C-0LPQuNC4"></a>
## Немного терминологии

Надеюсь, вас уже не пугают такие слова, как объект и тип. Мы не раз с ними сталкивались в различном контексте. Но сейчас
 пришло время определиться с точным значением и отношением между этими двумя понятиями.
 
Итак, философски, *объект*, иначе *сущность* -- это воплощение некоего понятия, которое имеет определённые характеристики (свойства)
и определённое поведение. *Тип* -- это абстракция или шаблон для подобных объектов, описывающий их возможные свойства и поведение.
То есть, тип -- это описание класса :clock2: подобных объектов. Рассмотрим, например, автомобили (мы не раз будем обращаться к этой аналогии):
*тип* кузова (например, "седан") реализуется в конкретных автомобилях (*объектах*, например, "Жигули" 2101). Двигатель
 (объект) может быть, например, бензинового или дизельного *типа*, и т.д.

Технически, в программировании, *объект* -- это некая область в памяти, заполненная по определённому его *типом* шаблону набором
характерных свойств и поведенческих функций, называемых методами.

Наличие объектов можно отметить во многих языках программирования, а типов -- пожалуй, во всех, начиная от ассемблера. Однако,
объектно-ориентированное программирование несёт в себе больше, чем просто программирование объектов и типов.

<a name="0JLQutGA0LDRgtGG0LUg0L7QsSDQvtCx0YrQtdC60YLQvdC-LdC-0YDQuNC10L3RgtC40YDQvtCy0LDQvdC90L7QuSDQv9Cw0YDQsNC00LjQs9C80LU"></a>
### Вкратце об объектно-ориентированной парадигме

Не углубляясь в теорию, но всё-таки желая некоторого понимания, что же из себя представляет подход [ООП](#oop) и чем он полезен,
попробуем разобраться.
Итак, ООП зиждется на трёх понятиях:
* наследование,
* полиморфизм,
* инкапсуляция.

:star: *Наследование* -- это возможность определить новый тип данных на основании уже существующего (родительского), 
свойства и поведение объектов которого копируются
 из родительского типа, за исключением тех, которые явно определены в новом типе. 

:star: *Полиморфизм* -- это  возможность работать
  с объектом такого нового типа как с объектом родительского.
  
:star: *Инкапсуляция* -- это объединение свойств и поведения в одной сущности объекта, 
а также возможность абстрагироваться от деталей реализации поведения и данных, относящихся к этому объекту.
 
Практически, мы во многих областях жизни используем объектно-ориентированный аппарат. Взять, например, управление автомобилем.
Любая машина, как объект типа "средство передвижения", предоставляет возможность перемещаться. У большинства авто 4 колеса
(следующий уровень в иерархии типов -- уровень 4-колёсности), далее идут тип кузова, тип двигателя, и т.п., но всё это
в общем не меняет того, что руль и 2-3 педали дают возможность управлять любой машиной примерно
 одинаковым способом (полиморфизм). Инкапсуляция же -- это тот факт, что такие вещи, как тип или объём двигателя, 
 тип кузова или цвет, существенно не влияют на способ управления.
 
:star: Этот способ называется *"интерфейс"*. Интерфейс -- совокупность свойств и поведения, служащих для реализации
 определённой задачи.

<a name="0KLQuNC_0Ysg0LTQsNC90L3Ri9GFINCyINCe0J7Qnw"></a>
### Типы данных в ООП

*(Этот раздел теоретический и может быть при желании пропущен)*

Как мы выяснили, тип -- это абстракция или шаблон. Выше было особенно отмечено слово "класс": в терминах ООП, абстракции, 
описывающие
свойства и/или поведение, обычно именуются *классом*, отчасти потому, что класс -- это более узкое обобщение, несущее 
более детальные и специализированные характеристики, чем тип, и даже, возможно, общие для разных типов. 
Продолжая аналогии с машинами -- к типу "легковая машина" может принадлежать и машина гоночного класса, и
класса "купе" или "повышенной проходимости", при этом гоночного класса может быть и грузовик или болид Формулы-1. 

В отличие от *класса*, под *типом* данных обычно понимается сугубо техническая единица, обусловленная архитектурой
компьютера. Так, тип данных "целое число" -- это совокупность объектов, над которыми компьютер осуществляет операции из
встроенного набора целочисленных инструкций, строковые типы данных позволяют использовать инструкции последовательной обработки, и т.п.
Чаще всего, такие типы данных не позволяют менять интерфейс.
 
:point_up: Тип данных "Объект" -- это абстракция, определяющая свойства и поведение, общие для всех объектов. Таким
 образом, объект любого класса будет принадлежать к типу данных "Объект". Главное отличие объекта от других типов данных --
возможность изменять встроенный или задавать собственный интерфейс. 
 
<a name="0KLQuNC_0Ysg0Lgg0LrQu9Cw0YHRgdGLINCyIFB5dGhvbg"></a>
## Типы и классы в Python

<a name="0JLRgdGRINCy0L7QutGA0YPQsyAtLSDQvtCx0YrQtdC60YLRiw"></a>
### Всё вокруг -- объекты

Язык Python, несмотря на свою поддержку различных парадигм программирования -- структурной, императивной, функциональной --
является всё-таки объектно-ориентированным языком. Можно даже сказать, абсолютно таковым. Любая сущность в Питоне 
(в отличие от большинства других ЯП, претендующих на звание объектно-ориентированных),
будь то число, строка, словарь, функция -- является объектом. Сама сущность типа, то есть,
сущность, хранящая в себе информацию о свойствах и поведении объектов этого типа,
также является объектом в Python. Наверно, самый интересный вопрос -- а как же так, что объект имеет тип, который в свою очередь является
объектом? Да, возможно, на первый взгляд это удивительно, но вполне логично. Представление типов данных в виде объектов
позволяет применять к ним единый общий подход, определять их интерфейсы (например, тот, который отвечает за получение информации
при создании объекта) и пользоваться другими полезными эффектами ООП.

<a name="0KLQuNC_0Ys"></a>
### Типы

Как мы уже знаем, тип сущности в Python можно узнать с помощью функции `type()`. Принадлежность же сущности (объекта) к какому-либо типу
можно проверить с помощью функции `isinstance()`.
```python
assert type(1) == int
assert type(int) == type
assert type(object) == type
assert type(type) == type

assert isinstance(1, object)
assert isinstance(int, object)
assert isinstance(object, object)
assert isinstance(type, object)
```
Получается, тип сущности `type` -- тоже `type`, но при этом сущность  `type` принадлежит *и* к типу `object`. А тип `object`
и вовсе принадлежит к типу имени самого себя.

Мы вскользь упоминали о наследовании типов в [лекции 7](./lecture_07.md), и сегодня узнаем об этом подробнее, а пока
просто запомним, что тип `object` является тем самым корневым типом-прародителем всех сущностей языка Python.

Как именно проявляются три основных концепции ООП в объектах Python?
* Наследование:
    * Все типы являются производными от типа `object` или производных от него типов, глубина иерархии наследования
      не ограничена.
    * Все объекты наследуют от типа `object` возможность доступа к атрибутам (получение существующего атрибута
      через точку, вызов ошибки `AttributeError` при отсутствии атрибута), а также общие для всех объектов атрибуты `__class__`,
      `__repr__()` (метод репрезентации объекта при выводе в интерактивном режиме), `__str__()` (метод преобразования объекта
      в строку при, например, выводе в команде `print`) и некоторые другие.
* Полиморфизм: все объекты могут быть переданы в качестве параметра функции `type()`, которая возвращает значение в
  зависимости от типа объекта.
* Инкапсуляция: реализация механизма обмена данными между объектами не принципиальна, коль скоро этот обмен производится
  в интерфейсе, предоставляемом синтаксисом Python (как пример, доступ к атрибутам через точку. Впрочем, :clock2: Python позволяет
  использовать и другие, более "глубокие" механизмы доступа к атрибутам, при использовании которых знание этого механизма
  требуется и его детали имеют значение.)  

<a name="0JrQu9Cw0YHRgdGL"></a>

### Классы

В терминологии Python, тип -- это всякий шаблон, определяющий интерфейс объекта, а *класс* -- это просто тип, 
который создаётся пользователем (то есть, программистом на Python). 

Так как интерфейс -- это совокупность свойств и методов объекта, то класс как раз и позволяет задать *свойства* и *методы*.
 
Синтаксически, класс определяется через указание ключевого слова `class`, названия класса и при необходимости, в скобках,
 перечисления типов, от которых класс наследуется, после чего следует блок кода, который может содержать одно или несколько
  утверждений присваивания (устанавливающих свойства) либо определений функций (устанавливающих методы).
 
```python
class MyClass:
    pass

class Car(object):
    color = None
```
 
В примерах выше мы объявили один пустой класс `MyClass` и класс Car, производный от типа `object` и имеющий одно свойство
`color` со значением `None` по умолчанию.

:point_up: Название класса в Python принято записывать в виде "CamelCase", то есть все составляющие слова
записываются с заглавной буквы в один идентификатор, без разделителей в виде `_` .

:exclamation: Хотя синтаксически совершенно корректно полностью опускать список родительских классов в объявлении класса,
на практике в Python 2.X во многих случаях необходимо указать хотя бы тип `object`. Это потому, что в 2.X версиях Python
существуют две разновидности классов -- старые и новые. Старые уже устарели и их крайне не рекомендуется использовать,
поэтому в дальнейшем будем рассматривать только новые, которые содержат как минимум `object` в иерархии наследования.

<a name="0J7QsdGK0LXQutGC0Ysg0LrQu9Cw0YHRgdCw"></a>

### Объекты класса

Определив класс, мы можем создать объект этого класса путём "вызова" класса как функции:

```python
my_object = MyClass()
assert type(my_object) is MyClass
assert isinstance(my_object, MyClass)

car = Car()
assert type(car) is Car
assert isinstance(car, Car)
assert car.color is None
```

Как видим, у объекта `car` класса `Car` имеется свойство (атрибут) `color`, которое было определено в объявлении класса. Пришло
время поговорить о свойствах подробнее.

<a name="0KHQstC-0LnRgdGC0LLQsCwg0L_QvtC70Y8sINCw0YLRgNC40LHRg9GC0YsuINCd0LXQvNC90L7Qs9C-INGC0LXRgNC80LjQvdC-0LvQvtCz0LjQuC4"></a>

### Свойства, поля, атрибуты. Немного терминологии.

Определение понятию "атрибут" мы давали в лекции №6, но имеет смысл повторить его здесь. 

:star: В Python, *атрибут* объекта -- это другой объект, связанный с первым отношением членства, таким, что операция
     "точка" применительно к первому с указанием имени атрибута возвращает второй объект. 
     
Это сугубо техническое определение, но в данном случае оно наиболее точно отражает суть отношения.

:star: *Свойство* -- это атрибут, имеющий непосредственное значение (то есть не являющийся методом). 

:star: *Поле* -- это свойство объекта в том виде, в котором оно указывается в определении класса. Поля -- это шаблоны
для свойств объекта, выполняющие в Python две задачи: 
* информировать пользователя класса о наличии у его объектов данных свойств;
* предоставлять для объектов значения свойств по умолчанию.

И тут мы подошли к важному аспекту работы Python с атрибутами.

<a name="0JzQtdGF0LDQvdC40LfQvCDQtNC-0YHRgtGD0L_QsCDQuiDRgdCy0L7QudGB0YLQstCw0Lwg0L7QsdGK0LXQutGC0L7Qsi4g0J3QsNGB0LvQtdC00L7QstCw0L3QuNC1INGB0LLQvtC50YHRgtCy"></a>

### Механизм доступа к свойствам объектов. Наследование свойств

Итак, мы определили класс `Car` и создали объект этого класса: 
 
```python
class Car(object):
    color = None
car = Car()
assert car.color is None
```

Как следствие того, что класс -- это шаблон объектов, объект получил атрибут `color`, значение которого равно по умолчанию `None`.

Есть ли у объекта `car` какие-то ещё атрибуты? Да, у него есть те самые `__class__`,  `__repr__()`, `__str__()` и ещё
набор атрибутов, унаследованных от типа `object`, упомянутых в начале лекции.  

:exclamation: Кроме них, есть ещё замечательный атрибут `__dict__`. Он настолько важен, что не сказать пару слов о нём просто нельзя,
хотя и немного рано. Атрибут `__dict__`, если он есть у объекта, хранит в себе словарь его собственных атрибутов в виде
ключ словаря -- имя атрибута, значение под этим ключом -- значение атрибута. Если у объекта есть  `__dict__`, то
он может не только отдавать существующие атрибуты, но и получать новые! Это делается простым присваиванием атрибуту значения:

```python
car.speed = 100
assert car.__dict__['speed'] == 100
```
и у объекта `car` появился атрибут, не определённый в интерфейсе его класса. При этом, определение класса никак не поменялось,
и другие объекты класса, как существующие, так и новые, о новом атрибуте 
объекта `car`ничего не узнают! Поэтому такие атрибуты и называются *собственными*.

Именно отсутствие атрибута `__dict__` у объектов типа `object` является причиной того, что им невозможно задать новые атрибуты.
Впрочем, для того, чтобы получить "чистые" объекты, которым можно задавать любые атрибуты, достаточно объявить "пустой" класс, 
наследующий от `object`:

```python
class MyClass(object):
    pass
my_obj = MyClass()
my_obj.my_attribute = "test"
```

:point_up: Наличие атрибута `__dict__` даёт много разных возможностей. Но на текущий момент можно про него забыть, так как
инкапсуляция доступа к атрибутам делает его ненужным в повседневной жизни.

:exclamation: Операции получения значения атрибута и установки значения происходят по-разному.

Как мы выяснили, у объектов могут существовать собственные атрибуты. 
При поиске атрибута для, первым делом, Python смотрит в словарь
собственных атрибутов, далее, если не находит там нужный ключ -- в атрибуты, определённые в классе объекта. 
Если же не нашёл и в классе -- продолжает поиск в родительском классе, затем в прародительском и далее вверх по иерархии.
Так как у любого объекта общий прародитель -- тип `object`, то атрибут, не имеющийся ни в одном из типов иерархии, ни
в типе `object`, считается ненайденным и вызывает ошибку `AttributeError`. Поиск производится именно в такой последовательности,
что даёт возможность *переопределить* атрибут, заданный в одном из "старых" классов (выше по иерархии), в более новых 
 и даже в самом объекте. В таком случае Python будет брать то значение, которое ближе всех к объекту. Проиллюстрируем
  это в коде:

```python
class Car(object):
    color = None
class DieselCar(object):
    engine = "diesel"
class RedCar(DieselCar):
    color = "red"
car = RedCar()
assert car.color == "red"
assert car.engine == "diesel"

car.color = "black"
assert car.color == "black"
```
В данном примере у нас иерархия глубиной 4 типа; при запросе атрибута `color` в первом `assert`, Python находит его
в классе RedCar. Во втором `assert`, атрибут `engine` находится в более высоком классе DieselCar. И, наконец,
после установки нового значения атрибута `color` объекту, оно теперь находится среди его собственных атрибутов.

:exclamation: Установка (присваивание) значения атрибута (в нашем случае, `color`) **всегда** происходит в собственные атрибуты объекта,
независимо от наличия этого атрибута у каких-либо типов в иерархии.

Возникает забавный вопрос: а можно ли поменять поле класса и что будет с объектами этого класса? Ответ -- в духе Python --
очень логичен.
* Поля класса, то есть его атрибуты, можно точно так же получать и присваивать, так как любой класс является объектом
  имени себя:
```python
class Car(object):
    color = None
assert Car.color is None
Car.color = "red"
assert Car.color == "red"
```  
* Поиск атрибутов происходит всегда по описанному сценарию, поэтому изменение полей класса затронет *все* объекты этого класса,
  у которых не присвоен собственный атрибут. Изменение полей родительского класса, аналогично, затронет *все* производные
  классы, у которых не переопределено это поле, и соответствующие объекты этого и производных классов.

<a name="0JzQvdC-0LbQtdGB0YLQstC10L3QvdC-0LUg0L3QsNGB0LvQtdC00L7QstCw0L3QuNC1"></a>

### Множественное наследование

В отличие от довольно многих ЯП, Python позволяет классам иметь не один, а сколько угодно родительских типов.
Ограничений нет, кроме одного: не должно быть так, чтобы в этой иерархии два типа были зависимы один от другого.
Это крайне редкое явление и им можно пренебречь. В практике множественное наследование главным образом применяется
для объявления и использования так называемых "примесей" (*mixin*). Это когда некоторая функциональность может быть
присуща разнородным объектам, которые никак не возможно отнаследовать от одного общего предка, ею наделённого.

Скажем, в случае с автомобилями, хорошей аналогией будут светодиодные фары, или система ABS, или тот же цвет: 
сложно себе представить эффективную иерархию типов машин, которые имеют общий тип с ABS, красного цвета, и со светодиодными фарами,
но разные двигатели и кузова. С помощью миксинов подобное реализуется наглядно и эффективно:

```python
class Car(object):
    abs = None
    headlight_type = "normal"
class CarDiodeHeadlightMixin(object):
    headlight_type = "diode"
class CarABSMixin(object):
    abs = True
class LexusES(CarDiodeHeadlightMixin, CarABSMixin, Car):
    pass
lexus = LexusES()
assert lexus.abs == True
assert lexus.headlight_type == "diode"
```

Этот пример, конечно, немного надуманный, но показывает мощь реализации ООП в Python. 

При множественном наследовании, поиск атрибутов происходит в том же логическом порядке, при этом (условно) 
 сперва просматривается иерархия первого указанного в родителях класса, затем второго и т.д. В реальности, используется
 оптимизация, позволяющая не просматривать дважды класс, уже просмотренный в качестве родителя одного из предыдущих классов.
 
Однако, следует помнить, что если ваши миксины *переопределяют* какое-то поле одного из родительских классов, то
порядок их указания отражается на порядке поиска атрибута. Именно поэтому в примере выше мы указали класс `Car` последним,
 так как атрибут `abs` миксина `CarABSMixin` нам важнее, чем класса `Car`, и то же с атрибутом `headlight_type`.
 

[Следующая лекция](./lecture_12.md) [Оглавление](./README.md) [Предыдущая лекция](./lecture_10.md) 

## Примечания

<a name="oop">
*ООП* -- Объектно-ориентированное программирование