Лекция 11. Объектная модель Python
===


### Значки, используемые в тексте

* :clock2: &mdash; отмечает, что высказывание не совсем верно, но будет уточнено позднее.
* :star: &mdash; выделяет определение нового понятия.
* :exclamation: &mdash; привлекает внимание к высказыванию.
* :point_up: &mdash; указывает на небольшое отступление от темы или уточнение.
* :bulb: &mdash; индикатор традиций и договорённостей. 
* :warning: &mdash; требуется осторожность: возможно, сложное высказывание.  



[Следующая лекция](./lecture_12.md) [Оглавление](./README.md) [Предыдущая лекция](./lecture_10.md) 

## Курица или яйцо?

Язык Python, несмотря на свою поддержку различных парадигм программирования -- структурной, императивной, функциональной, --
является всё-таки объектно-ориентированным языком. Можно даже сказать, абсолютно таковым. Любая сущность в Питоне 
(в отличие от большинства других ЯП, претендующих на звание объектно-ориентированных),
будь то число, строка, словарь, функция -- является объектом. Объекты принадлежат к разным типам, но и сущность типа, то есть,
сущность, хранящая в себе информацию о свойствах и поведении объектов этого типа,
также является объектом. Наверно, самый интересный вопрос -- а как же так, объект имеет тип, который в свою очередь является
объектом? Да, это определение, возможно, на первый взгляд, удивительное, вполне логично: что раньше, курица или яйцо? 
Ни курица, ни яйцо не могут существовать одно без другого. 

Как мы уже знаем, тип сущности в Python можно узнать с помощью функции `type()`. Принадлежность же сущности (объекта) к какому-либо типу
можно проверить с помощью функции `isinstance()`.
```python
assert type(1) == int
assert type(int) == type
assert type(object) == type
assert type(type) == type

assert isinstance(1, object)
assert isinstance(int, object)
assert isinstance(object, object)
assert isinstance(type, object)
```
Получается, тип сущности `type` -- тоже `type`, но при этом сущность  `type` принадлежит *и* к типу `object`. А тип `object`
и вовсе принадлежит к типу имени самого себя.
Мы вскользь упоминали о наследовании типов в [лекции 7](./lecture_07.md), и сегодня узнаем об этом подробнее, а пока
просто запомним, что тип `object` является тем самым корневым типом-прародителем всех сущностей языка Python.

### Вкратце об объектно-ориентированной парадигме

Не углубляясь в теорию, но всё-таки желая некоторого понимания, что же из себя представляет подход ООП[1] и чем он полезен,
попробуем разобраться.
Итак, ООП зиждется на трёх понятиях:
* наследование
* полиморфизм
* инкапсуляция.

:star: *Наследование* -- это возможность определить новый тип данных на основании уже существующего (родительского), 
свойства и поведение объектов которого копируются
 из родительского типа, за исключением тех, которые явно определены в новом типе. 

:star: *Полиморфизм* -- это  возможность работать
  с объектом такого нового типа как с объектом родительского.
  
:star: *Инкапсуляция* -- это объединение свойств и поведения в одной сущности объекта, 
а также возможность абстрагироваться от деталей реализации поведения и данных, относящихся к этому объекту.
 
Практически, мы во многих областях жизни используем объектно-ориентированный аппарат. Взять, например, управление автомобилем.
Любая машина, как объект типа "средство передвижения", предоставляет возможность перемещаться. У большинства авто 4 колеса
(следующий уровень в иерархии типов -- уровень 4-колёсности), далее идут тип кузова, тип двигателя, и т.п., но всё это
в общем не меняет того, что у машины руль и 2-3 педали, дающие возможность управлять любой машиной примерно
 одинаковым способом (полиморфизм). Инкапсуляция же -- это тот факт, что такие вещи, как тип или объём двигателя, 
 тип кузова или цвет
существенно не влияют на способ управления.
 
:star: А этот способ называется *"интерфейс"*.

## Классы в Python



[1] Объектно-ориентированное программирование