Лекция 8. Ввод-вывод в файлы. Конструкция `with` 
=========


### Значки, используемые в тексте

* :clock2: &mdash; отмечает, что высказывание не совсем верно, но будет уточнено позднее.
* :star: &mdash; выделяет определение нового понятия.
* :exclamation: &mdash; привлекает внимание к высказыванию.
* :point_up: &mdash; указывает на небольшое отступление от темы или уточнение.
* :bulb: &mdash; индикатор традиций и договорённостей. 
* :warning: &mdash; требуется осторожность: возможно, сложное высказывание.  

### Повторение терминов из седьмой лекции

* *Конструкция `try-except-else`* &mdash; синтаскическая конструкция (сложное утверждение), предназначенная
    для обработки исключений из блока `try` в блоках `except` и выполнения блока `else` в случае отсутствия ошибок.
* *Утверждение `raise`* &mdash; утверждение, дающее возможность непосредственно вызвать исключение в коде.

## Файлы в Python

Что такое файл? С точки зрения Python, это объект файловой системы, поддерживающий потоковое чтение и запись.

Для того, чтобы начать работу с файлом (чтение или запись), необходимо открыть файл, с указанием вида работы.
  
Файл обычно идентифицируется именем, и Python также использует имя файла для его открытия, которое осуществляется
 встроенной функцией `open()`:
 
```python
f = open("somefile.txt")
```

Функция `open()` принимает как минимум 1 аргумент -- имя файла -- и возвращает объект типа `file` (также встроенный
в Python тип), с которым далее и ведётся работа. Вторым аргументом функции указывается способ работы,
то есть чтение или запись;  по умолчанию, файл открывается на чтение.
 
У объекта файла есть набор атрибутов и методов, которые в дальнейшем используются для работы с файлом.
   
Имя файла, связанного с объектом, доступно через атрибут `file.name`: 

```python
f = open("somefile.txt")
assert f.name == "somefile.txt"
```

При отсутствии такого файла или невозможности открыть его (например, нет разрешений, либо файл является каталогом)
возникнет исключение `IOError`.

Чтобы прочитать содержимое файла, используется метод `file.read()`. Он возвращает Python-строку (`str`) 
 состоящую из всего содержимого файла, либо если передать ему 1 аргумент -- целое число N, то строка будет
 состоять из первых N байт файла (либо файла целиком, если его размер меньше N байт).
 
Можно написать программу из 2 строк, которая
выведет собственный код, для этого достаточно сохранить её в файл например `program1.py` и написать:

```python
f = open("program1.py")
print f.read()
```

## Указатель позиции в файле

Если вызвать метод `file.read()` без аргументов более одного раза, то он вернёт пустую строку:

```python
f = open("program1.py")
print f.read()
assert f.read() == ""
```

Объяснение этому таково.
Файл можно представить как упорядоченную последовательность байт, каждый из которых имеет индекс, начиная с 0 
(первый байт) и до "размер файла - 1". При чтении данных из файла, каждый байт условно по очереди 
передаётся в строку-результат, и индекс (указатель на текущий байт) увеличивается. По окончании чтения, 
 индекс остаётся в том же месте, и следующее чтение начнётся с этого индекса. Если мы уже прочитали весь файл, то
логично, что данных после текущего указателя уже нет.  

Метод `file.read()` не только читает данные из файла, но и увеличивает указатель на кол-во прочитанных байт.
Если в цикле читать из файла по одному байту, то каждый раз в результате чтения будет следующий байт, до тех пор,
  пока мы не достигнем конца файла.


## Текстовые и бинарные файлы 

Во многих системах файлы бывают двух "разновидностей": текстовые и двоичные (бинарные). В общем любой файл
  можно считать бинарным, особенно если нам не требуется работать с файлом по частям. Если мы считываем весь файл
   в строку с помощью метода `file.read()`, то далее мы можем работать со строкой, полностью игнорируя вид файла.

Главное отличие этих видов в семантике доступа: для текстовых файлов имеет смысл построчный доступ, для бинарных --
посимвольный или буферизованный.

С точки зрения пользователя, вид файла не всегда имеет значение, скажем, 
файл с данными xml или json по содержанию является текстовым, но едва ли имеет смысл обрабатывать его построчно,
  так как данные представляют собой единую структуру. В то же время файл типа `doc` для пользователя представляет
  двоичную кодировку текста.

## Работа с текстовыми файлами

Типичным текстовым файлом является файл программы на Python. Для построчного чтения текстовых файлов существует
 метод `file.readline()`, который читает строку из файла и увеличивает указатель на длину прочитанной строки.
  При этом конец строки определяется настройками текущей ОС: для Linux концом строки служит символ перевода строки
  `"\n"` (или `"\x0a"`), для Windows -- последовательность `"\r\n"` (или `"\x0d\x0a"`).

Этот метод удобно использовать в цикле `while`, опять же проверяя, что считанная строка не пустая. Также в этом методе можно
 задавать максимальную длину считываемой строки.
  
Для большего удобства построчного чтения файлов целиком, в цикле `for` мы можем использовать метод `file.readlines()`:

```python
f = open("somefile.txt")
for line in f.readlines():
    print line
```

Или даже ещё проще:

```python
f = open("somefile.txt")
for line in f:
    print line
```

Объект типа файл является *итерируемым*, как списки и строки, и итерируется по строкам, содержащимся в файле.

## Работа с бинарными файлами

Для итеративной (поблочной) работы с бинарными файлами используется метод `file.read(N)`, 
где N -- размер считываемого блока. Проверять, что достигнут конец файла, можно, сравнивая длину результата с N,
 либо также считывать до получения пустой строки.
 
У бинарных файлов есть ещё одно отличие: мы можем узнать, где сейчас указатель, и 
передвинуть указатель вручную на нужное место. (То есть, мы *можем* это делать и в текстовых файлах, но там
 это бессмысленно.) Для этого предназначены два соответствующих метода: `file.tell()` и `file.seek()`.
 
Первый возвращает индекс байта, на котором сейчас указатель; второй -- принимает число-индекс в качестве аргумента 
и устанавливает указатель на этот индекс.

Таким образом, мы в теории сможем при достижении конца файла вернуть указатель на начало и прочитать содержимое заново.
Впрочем, на практике это крайне редко используется.

## Запись в файл

Для разрешения записи в файл, как мы уже упомянули выше, необходимо сообщить функции `open()`, что мы открываем
  файл на запись. Режим работы с файлом передаётся вторым аргументом функции `open()` и представляет собой строку.
  
Запись может быть двух видов: перезапись (создание файла, если его ещё нет, либо пересоздание файла, если он уже есть)
и дозапись (добавление в конец файла, если он есть, либо ошибка IOError в случае отсутствия).

Режим записи обозначается строкой `"w"`, режим добавления -- строкой `"a"`. 

Далее, собственно писать в файл можно исользуя метод `file.write()`, который принимает параметр -- Python-строку с 
содержимым для записи. При записи, как и при чтении, указатель позиции в файле увеличивается на количество записанных байт.

```python
f = open("somefile.txt", "w")
f.write("test")
```

Однако если просто записать в открытый файл, записанные данные не сохранятся. Для сохранения данных необходимо
*закрыть* файл, это делается методом `file.close()`.


```python
f = open("somefile.txt", "w")
f.write("test")
f.close()
```

*Примечание:* файлы сами закрываются при выходе из программы, но крайне рекомендуется закрывать их вручную во избежание
ошибок.

## Смешанные режимы открытия файла

Возможно также открыть файл в режиме, совмещающем чтение и запись. Существует три таких режима:
* чтение с возможностью записи, режим `"r+"`
* перезапись с возможностью чтения, режим `"w+"`
* дозапись с возможностью чтения, режим `"a+"`

Они в целом соответствуют своим "основным" режимам. 


## Некоторые синтаксические конструкции, облегчающие работу с файлами

Представим себе ситуацию, что мы обрабатываем файл построчно и ищем какую-то строку, после которой дальнейшая обработка
уже не имеет смысла. Используя цикл `for`, нам бы пришлось создавать переменную-флаг и "вхолостую" пробегать остаток
файла, проверяя этот флаг в каждой итерации. 

    в_обработке = 1
    ДЛЯ КАЖДОЙ СТРОКИ ФАЙЛА
        ЕСЛИ в_обработке:
            ЕСЛИ строка СОДЕРЖИТ "КОНЕЦ":
                в_обработке = 0
        

К счастью, в Python можно обойтись куда более простой конструкцией.
 
### Утверждение `break`

Утверждение `break` даёт команду немедленно выйти из цикла к следующему за ним утверждению, полностью пропустив оставшиеся
итерации и также все утверждения, идущие в блоке кода цикла после `break`.

    ДЛЯ КАЖДОЙ СТРОКИ ФАЙЛА
        ЕСЛИ строка СОДЕРЖИТ "КОНЕЦ":
            BREAK

```python
f = open("somefile.txt")
for line in f:
    if "end" in line:
        break
    print line
```

В данном случае будет выводиться на экран каждая строка до строки, содержащей "end", не включая её, потому что 
цикл закончится до вывода её на экран.

Утверждение `break` можно использовать не только в обработке файлов, и не только в цикле `for`: циклы `while` также
поддерживают его. Но в любом другом блоке кода, который не относится к циклам, использование `break` является синтаксической
ошибкой.
 
### Утверждение `continue`
 
Утверждение `continue` является дополнением `break`: оно пропускает все следующие за ним утверждения в *блоке кода цикла* 
 и переходит к следующей его итерации. В случае с циклом `for` это означает -- к обработке следующего элемента (если он есть),
 в случае `while` -- к следующей проверке условия. 

Его удобно использовать, если нам нужно, наоборот, начать обработку файла с какой-то строки файла
или пропустить обработку строки.

```python
f = open("somefile.txt")
for line in f:
    if "start" not in line:
        continue
    if "skip" in line:
        continue
    print line
```

Этот код будет пропускать все строки файла до строки, содержащей "start", начиная с неё, он начнёт выводить все те строки,
которые *не содержат* "skip".

### Конструкция `with`

Объект файла, будучи *итерируемым объектом* (типа контейнера) является ещё и так называемым *контекстным менеджером*.

Контекстный менеджер умеет автоматически выполнять некторые действия по окончанию выполнения определённого *контекста*,
 который задаётся конструкцией `with`:
 
    with КОНТЕКСТНЫЙ_МЕНЕДЖЕР as ПЕРЕМЕННАЯ:
        БЛОК_КОДА
        
БЛОК_КОДА в данном случае и является контекстом. Независимо от того, произошли ли ошибки в БЛОКе_КОДА, контекстный
  менеджер всегда выполнит завершающие действия, а именно для файлов -- их закрытие.
        
Возьмём пример, использованный выше: 

```python
f = open("somefile.txt", "w")
f.write("test")
f.close()
```

Его можно переписать так:

```python
with open("somefile.txt", "w") as f:
    f.write("test")
```

И файл автоматически будет закрыт по окончанию блока кода в `with`. 


## Задания

1. Записать в новый текстовый файл числа от 1 до 10 по одному в строке. 

    Примечания: 
    * в файл можно записать только строковые данные.
    * В конец записываемой строки необходимо добавлять символы перевода строки, для Windows это последовательность `"\r\n"`.
    
2. Прочитать из записанного файла числа от 3 до 7 включительно, используя `break` и `continue`. 
   В результате должен получиться список из 5 чисел.

    Примечания: 
    * из файла читаются строковые данные.
    * для отбрасывания символов перевода строки используйте метод `str.strip()`.

