Лекция 3. Функции в Python. Циклы. Логические типы данных
=========

### Значки, используемые в тексте

* :clock2: &mdash; отмечает, что высказывание не совсем верно, но будет уточнено позднее.
* :star: &mdash; выделяет определение нового понятия.
* :exclamation: &mdash; привлекает внимание к высказыванию.
* :point_up: &mdash; указывает на небольшое отступление от темы или уточнение.
* :bulb: &mdash; индикатор традиций и договорённостей. 
* :warning: &mdash; требуется осторожность: возможно, сложное высказывание.  

## Повторение материала предыдущей лекции

* *Утверждение "напечатать" (print-statement)* &mdash; выводит значение выражения на стандартный вывод программы,
  начинается с ключевого слова `print`, за которым (отделённое пробелом) следует выражение. 
* *Управляющая структура* &mdash; конструкция, позволяющая изменять 
последовательность выполнения утверждений в программе.
* *Сложное утверждение* &mdash; утверждение, содержащее знак `:` и допускающее вложенные утверждения.

## Встроенные функции

Кроме *ключевых слов*, в Python существуют и другие элементы синтаксиса, которые не нужно объявлять. Как мы помним, *операторы* 
`+`, `-`, `=` и прочие являются встроенными в язык. Но пожалуй самым распространённым видом элементов языка Python являются функции.

Как и в математике, функция &mdash; это сущность, которая может принимать значения и возвращать результат. 
Возьмём, например, линейную функцию: 

    y = f(x) ; f(x) = kx + b

В этом примере функция `f` принимает значение `x` и возвращает результат `kx + b`, где `k` и `b` &mdash; константы. 
Если мы установим `k=2`, `b=3`, функция будет выглядеть как `f(x) = 2x + 3`. 
Подставив `x = 1`, получим результат `2*1 + 3 = 5`.

Как создать собственную функцию на Python, мы рассмотрим чуть ниже, 
а сейчас возьмём другую математическую функцию - абсолютной величины числа.
(Напомним, эта функция возвращает `x`, если он больше или равен 0, или `-х`, если он меньше нуля, то есть её результат 
&mdash; всегда неотрицательное число.)

Назовём эту функцию не `f`, a `abs`.
В математической нотации это выглядит так:

    abs(x) = x, x >= 0; -x, x < 0

В Python такая функция является встроенной и называется ... `abs`. Каким же образом использовать эту функцию?  

Функции в Python вызываются почти так же, как выглядит их запись в математической нотации:
 
    abs(x)
    
Сначала идёт идентификатор функции, далее в круглых скобках через запятую перечисляются её *параметры* (или *аргументы*),
 количество которых определяется  
самой функцией (точнее, её определением, или *сигнатурой*). Аргументов может и не быть вообще.  
Функция `abs(x)`, например, принимает один аргумент.

:exclamation: Аргументом функции может быть любое выражение, при этом собственно вызов функции также является выражением.

:bulb: По соглашению, вызов функции в Python записывается так: между идентификатором функции и открывающей скобкой,
 а также скобками и выражением-аргументом (-ами) пробелы *не ставятся*. Если у функции нет аргументов, то пробелы
  между скобками также не ставятся.

Теперь мы можем написать в нашем файле: 

```python
print abs(2)
```
   
Мы увидим результат &mdash; 2. Можем поэкспериментировать с выражениями: `abs(1-2)`, `abs(abs(5))`, `abs(5 - abs(5))`

### Возведение в степень: функция от двух аргументов и оператор `**`

Одна из простейших функций с двумя аргументами &mdash; возведение в степень `pow(x, y)`: 

```python
pow(5, 3)  # 125
```

возведёт `5` в степень `3`. Впрочем, обычно в Python
пользуются оператором возведения в степень: `**`

```python
5 ** 3  # Эквивалентно pow(5, 3)
```

Этот оператор имеет связывание сильнее, чем умножение и деление, но слабее, чем унарный *минус*. 
:point_up: При этом несколько последовательных операторов `**` вычисляются "справа налево":

```python
print 2 ** 2 ** 3  # 256
```

выведет `256` (2<sup>8</sup>), а не `64` (4<sup>3</sup>).

:point_up: Главное преимущество функции `pow()` в том, что она умеет возводить в степень по модулю: например 
`pow(2, 3, 5)` возведёт 2 в третью степень по модулю 5. Поэтому фактически эта функция может принимать как 2, 
так и 3 аргумента. 

### Ошибки с количеством аргументов. Функции с переменным числом аргументов

Если функция допускает какое-то известное количество аргументов, то при избытке или недостатке аргументов в вызове
функции возникнет ошибка:

    >>> abs()
    Traceback (most recent call last):
      File "<input>", line 1, in <module>
    TypeError: abs() takes exactly one argument (0 given)
    >>> pow(5, 10, 50, 100)
    Traceback (most recent call last):
      File "<input>", line 1, in <module>
    TypeError: pow expected at most 3 arguments, got 4
    
`TypeError` &mdash; ошибка типа &mdash; это исключение при несовпадении типа предоставленного значения с ожидаемым ()в данном 
 случае под "типом" понимается состав аргументов)
и оно ещё будет в дальнейшем нам встречаться. 

Мы уже увидели, что есть функции, для которых количество аргументов зависит от контекста. Есть и такие функции, где
допускается разное число аргументов с одним и тем же контекстом.

В качесте примера функции с переменным числом аргументов приведём полезные функции `min()`, `max()` и `sum()`.
Они вычисляют соответственно минимальный из переданных аргументов, максимальный и сумму. 
Количество аргументов этих функций может быть любым, от двух :clock2: до 255.

```python
print min(5, 1, 2, 3)  # 1
print max(5, 1, 2, 3)  # 5
print sum(5, 1, 2, 3)  # 11
```    

## Функция ввода (чтения) с клавиатуры
 
Когда вы решали задачи для второй лекции, вы наверно устали менять значения для констант в тексте программы.
Одним из важнейших свойств программ является возможность не задавать все данные в коде заранее 
(или, как говорят, хардкодить &mdash; "жёстко кодировать"),
а обрабатывать пользовательский ввод. Для этого существует функция `input()`. При вызове без аргументов, она 
передаёт управление на консоль и предоставляет возможность пользователю ввести с клавиатуры выражение на Python.
 
Если мы запустим python в интерактивном режиме и просто введём 

    >>> input()
     
мы увидим приглашение вида

    >?
    
после которого можно начинать ввод выражения, заканчивая его клавишей `Ввод`. Введённое выражение будет вычислено и
выведено в консоль.

В программе мы можем использовать `input()` в утверждении присваивания: результат вычисления введённого выражения будет 
 присвоен переменной.
 
Например, программа 

```python
x = input()
print x * x
```

сначала запросит ввод у пользователя, также показав приглашение `>?`, а затем
выведет результат пользовательского ввода, возведённый в квадрат.


## Объявление функций

Python предоставляет некоторое количество встроенных функций, но наиболее ценна возможность создавать новые, иначе говоря,
*пользовательские (user-defined)* функции.
 
Пользовательская функция в Python является разновидностью управляющих структур. 
По сути, функция может включать в себя любое количество кода &mdash; выражений или утверждений, с тем чтобы не повторять этот код
в разных местах или с тем, чтобы логически группировать (структурировать) код.  

:point_up: В хорошем стиле программирования популярен принцип **DRY** &mdash; Don't repeat yourself &mdash; не повторяйся.
Этот принцип гласит, что если что-то в программе используется более чем один раз, этот факт негативно сказывается на
восприятии кода и подвергает программу опасности ошибок, связанных с тем, что поменяв что-то в одном месте, в другом аналогичном
поменять забыли. Заключение повторяющегося кода в функции решает, в частности, и подобные проблемы.

Объявление функции в Python выглядит как *сложное утверждение*:

```python
def function(x):
    return x
```
    
Так будет выглядеть функция с названием (идентификатором) `function`, одним аргументом `x` и возвращаемым значением `x`.
Подобная функция, которая просто возвращает значение своего аргумента без изменения,  называется функцией идентичности,
математически она эквивалентна записи `f(x) = x`.

Остановимся подробнее на элементах объявления функции: ключевое слово `def`, за которым через один (:bulb: по традиции) 
пробел следует *идентификатор* функции, по которому её можно вызывать в коде; за ним (:bulb: по традиции, без пробела) 
следует открывающая скобка, далее перечисляются имена *аргументов*; их замыкают
  закрывающая скобка и знак `:`, после которого начинается *тело* функции.
  
:star: Тело функции &mdash; это блок кода, то есть одно или больше утверждений, выделенные отступом, 
либо :point_up: перечисленные в одной строке с разделителем `;` (точка с запятой). Последняя форма записи не является
хорошим стилем, но её может быть удобно использовать в интерактивном режиме.

:warning: В теле функции допускаются любые утверждения :clock2:, в частности утверждения присваивания, `print`, логические
конструкции `if-else` и т.п., даже вложенные объявления функций.   

### Утверждение "вернуть" (return-утверждение)

Чаще всего функция создаётся для того, чтобы *возвращать результат* &mdash; некое значение, которое вычисляется в теле функции. 
Для указания возвращаемого значения тело функции содержит `return`-утверждение. 

:star: Утверждение `return` &mdash; это команда интерпретатору "вернуть" вычисленное значение и завершить работу функции.

Утверждение `return` состоит из ключевого слова `return` и выражения, идущего за ним через один (:bulb: по традиции) пробел.
:point_up: Оно может встречаться только в теле функции. В любом другом месте программы наличие return-утверждения является
синтаксической ошибкой.


:exclamation: Обычно `return`-утверждение завершает блок кода (тело) функции, так как код, содержащийся в теле функции
после этого утверждения, не выполняется. Впрочем, в теле функции может быть любое количество `return`-утверждений. :clock2: 

### Механизм выполнения кода в процессе вычисления функции

:warning: Чтобы пояснить процесс выполнения программы, имеющей объявленные функции и вызывающей их, приведём в пример
функцию, преобразующую величину в процентах в вещественное число. 

Как мы помним, оператор деления `/` даёт в результате деления целых чисел целое число:
 
```python
x = 90
y = x / 100
print y  # выведет 0
```

поэтому нам необходимо сначала привести число к вещественному типу. 
Для этого, как описано в задании к прошлой лекции, мы можем использовать технику умножения 
на вещественную единицу `1.0`:

```python
x = 90
x = x * 1.0
y = x / 100
print y  # выведет 0.9
```

Каждый раз повторять этот код при использовании не очень удобно (хотя :point_up: в *данном случае* мы могли бы использовать 
и литерал `100.0`, это было бы гораздо понятнее).

Объявим функцию и вынесем повторяющийся код в неё. 

:exclamation: Функции можно объявлять в любом месте программы :clock2:, где допустимо утверждение, 
:bulb: обычно их объявляют в начале программы, отделяя одно объявление от другого (и от прочего кода) двумя пустыми строками.  

Наша программа будет выглядеть так:

```python
def from_percent(x):  # [1] объявление функции
    x = x * 1.0  # [2]
    return x / 100  # [3]


y = from_percent(90)  # [4] вызов функции
print y  # [5] выведет 0.9
```

При объявлении функции её тело *не выполняется*, только проверяется отсутствие в нём синтаксических ошибок.
Первой строкой программы, которая будет выполнена, является строка *[4]*, содержащая вызов функции. Чтобы вычислить
выражение, которым является вызов, выполнение программы перейдёт к первому утверждению тела вызываемой функции 
(другими словами, тело функции получит управление программой), 
на строке *[2]*, при этом переменной `x` &mdash; аргументу функции &mdash; 
будет присвоено значение, переданное в параметрах вызова, а именно `90`.  
Далее будут выполяться утверждения этого блока кода до первого утверждения `return`, которое у нас в строке *[3]*.
 
После обработки утверждения `return`, результат содержащегося в нём выражения будет передан в то место, где осуществлялся вызов &mdash;
в строку *[4]*, и это утверждение продолжит своё выполнение, заменив
выражение вызванной функции на её вычисленное значение.
и далее программа продолжит выполняться в той же последовательности, как и до вызова функции.
Итого, порядок выполнения строк будет таким: 4-2-3-(4)-5, где (4) значит, что утверждение получило управление повторно. 

Функция будет каждый раз получать управление при своём вызове, 
и каждый раз её тело будет вычисляться заново с указанными аргументами.

Добавим в нашу программу вычисление ещё одной процентной величины `z`:

```python
def from_percent(x):  # [1] объявление функции
    x = x * 1.0  # [2]
    return x / 100  # [3]


y = from_percent(90)  # [4] вызов функции
print y  # [5] выведет 0.9
z = from_percent(10)  # [6] вызов функции
print z  # [7] выведет 0.1
```

Функция `from_percent()` будет вызвана дважды, и каждый раз её аргументу `x` будет присвоено новое значение. Последовательность
 выполнения строк кода будет 4-2-3-(4)-5-6-2-3-(6)-7.
 
###  Контексты функции

:star: То место кода, в котором вызывается функция, называется контекстом вызова (выполнения) функции. То есть, функция вызывается
 из контекста вызова и после вычисления возвращает значение в контекст вызова.

Выше мы упомянули, что функцию можно объявлять в любом месте программы. Это верно, но с небольшим уточнением:

:exclamation: Контексту вызова должно быть известно о вызываемой функции. То есть, функция должна быть объявлена до
своего первого использования.
  
:point_up: Теоретически, мы можем объявить несколько функций с одинаковыми именами. В таком случае, как и в случае с переменными,
каждое новое объявление полностью "перетирает" предыдущее, и контекст вызова будет пользоваться той функцией,
которая была объявлена последней. Но контекст вызова не умеет смотреть вперёд.

Помимо контекста вызова, существует ещё и *контекст объявления функции*.

:star: Контекст объявления функции &mdash; это тот блок кода, в котором функция была объявлена.
 
В случае нашей программы, контекст объявления &mdash; это сама программа, которая фактически является блоком кода верхнего уровня. 

Контекст объявления функции имеет важную особенность: он негласно передаёт в тело функции все известные ему идентификаторы.
Так, следуя хорошему стилю, мы можем объявить используемые нами литералы `100` и `1.0` как *константы*, чтобы читателям
 программы было понятно их назначение:
 
 
```python
FLOAT_MULTIPLIER = 1.0  # [1]
PERCENT_DIVISOR = 100  # [2]


def from_percent(x):  # [3] функция, использющая ранее объявленные константы
    x = x * FLOAT_MULTIPLIER  # [4]
    return x / PERCENT_DIVISOR  # [5]


y = from_percent(90)  # [6] вызов функции
print y  # [7] выведет 0.9
```

Из примера видно, что тело функции может использовать объявленные ранее, в контексте объявления, константы `FLOAT_MULTIPLIER` 
и `PERCENT_DIVISOR`. 

Мы можем вызвать объявленную ранее функцию в другой функции, если контекст выполнения последней знает о первой: 


```python
FLOAT_MULTIPLIER = 1.0  # [1]
PERCENT_DIVISOR = 100  # [2]


def to_float(x):  # [3] функция, преобразующая аргумент в гарантированно вещественное число
    return x * FLOAT_MULTIPLIER  # [4] 


def from_percent(x):  # [5] функция, использющая ранее объявленные функцию и константы
    x = to_float(x)  # [6]
    return x / PERCENT_DIVISOR  # [7]


y = from_percent(90)  # [8]
print y  # [9] выведет 0.9
```

### Пара слов об идентификаторах

:bulb: По общепринятому соглашению, функции в Python именуются в стиле *Snake case*, то есть 
их названия состоят из строчных латинских букв и цифр от 0 до 9, при этом символ подчёркивания несёт смысл словоразделителя.

Переменные и функции могут называться одинаково, поэтому надо следить, чтобы их названия не совпадали. 
Впрочем, если вы будете следовать приведённому ниже совету, у вас такого не произойдёт.  

Очень важно правильно называть функции так, чтобы они отражали смысл своего существования (то, что они вычисляют).
Предпочтительно давать функциям названия в виде глагола в начальной форме с объектом-дополнением: 
`calculate_square` &mdash; вычислить квадрат, `make_float` &mdash; сделать вещественным, либо 
`convert_to_float` &mdash; конвертировать в вещественное: в аналогичных случаях часто используются
 выражения вида `to_float`, и т.п. Об исключениях, которые всё же существуют, мы будем особо сообщать.
 
:bulb: Переменные с идентификаторами вида `PERCENT_DIVISOR`, то есть записанные в заглавном регистре слова, 
с разделителями-символами подчёркивания, считаются *константами*. 
Фактически они выделяются только записью идентификатора. 
Они объявляются (им присваивается значение) один раз и далее только используются в выражениях.
:point_up: Фактически они не являются таковыми, то есть им можно присвоить и новое значение, но этого не рекомендуется делать,
так как это будет нарушать принятые соглашения и приводить как минимум к непониманию. Константы обычно именуются
существительными с определением: `PERCENT_DIVISOR` &mdash; процентный делитель, `BUTTON_COLOR` &mdash; цвет кнопки, 
 `REPETITIONS_COUNT` &mdash; количество повторений, и т.п.

Переменные обычно называют существительными (возможно, с определением) 
или причастиями: `color`, `current_color`, `data_ordering`. Для переменных название не так важно, потому что их использование
редко требуется за пределами небольшого участка кода. Функции и константы же могут использоваться в сотнях разных мест.

Говорят, что самое сложное в написании программ &mdash; это придумывать правильные названия переменным и функциям. 
Это недалеко от истины. В хороших программах грамотно названные сущности дают достаточно информации о происходящем, 
чтобы можно было не комментировать код. Помните правило "не повторяйся"? Можно не писать коммемнтарии о коде, 
когда всё очевидно из названий.
 
### Процедуры. Объект None

Довольно часто бывает, что нам не нужно значение, возвращаемое из функции. Например, мы хотим только вывести в консоль
значение аргумента. В этом случае мы можем просто не использовать присваивание значения &mdash; то есть, взывать функцию
как выражение. Возвращаемое ею значение будет проигнорировано: 

```python
def print_value(x):
    print x
    return 304958309 


print_value(10) 
```

Однако возникает вопрос, какое значение возвращать? А вдруг случайно кто-то возьмёт и присвоит это значение переменной,
 и там будет абракадабра? На этот случай предусмотрен специальный объект, который так и называется &mdash; "ничто": `None`.
Он встроен в язык Python, и является зарезервированным идентификатором: попытка присвоить значение объекту `None` вызовет
 синтаксическую ошибку. В то же время допустимо присвоить переменной значение `None`.

:star: Объект `None` &mdash; это специальная сущность, указывающая на отсутствие определённого значения. 

:point_up: Объект `None` не равен ни одному другому значению. В общем он ведёт себя аналогично  `null` в С, Java, Javascript. 

:exclamation: Если в теле функции отсутствует утверждение `return`, то функция автоматически возвращает объект `None`.

```python
def print_value(x):
    print x


print_value(10)  # выведет 10 
y = print_value(10)  # снова выведет 10
print y  # выведет None
```
Впрочем, можно и явно написать `return None`, результат будет такой же. Разница в том, какой смысл вкладывается 
в возвращаемое значение.   

:star: Функция, не возвращающая значения явно, по-другому называется *процедурой*. В приведённом выше примере,
функция `print_value(x)` является процедурой.

:point_up: Если в интерактивном интерпретаторе ввести выражение, результат которого `None`, интрепретатор просто переведёт
на следующую строку:

    >>> x = None
    >>> x
    >>>

### Аргументы пользовательских функций. Область видимости
  
В приведённом нами примере у объявленной функции был один аргумент. На самом деле, количество аргументов у пользовательской
функции может быть любым: их может не быть вообще, либо очень много (:point_up: если совсем честно, 
Python допускает до 255 аргументов, но на практике вряд ли вам понадобится и десяток).

Названия аргументов следуют правилам именования переменных &mdash; фактически, аргумент и есть переменная. Только она доступна
лишь внутри объявляющей функции. Иначе говоря, область видимости переменной-аргумента не распространяется наружу, 
ни в контекст объявления, ни в контекст вызова. 

То же правило действует для любой переменной, объявляемой внутри функции. Более того, если там объявить переменную, уже
существующую снаружи функции, то :warning: значение наружной переменной *никак не изменится*: 

```python
x = 10
 
def test():
    x = 100
    print x  # 100


test() 
print x  # 10
```

В результате присваивания `x` значения `100` внутри функции, была создана совершенно новая переменная, не влияющая на `x`
из первой строки.

Таким образом, имена аргументов и внутренних переменных могут совпадать с внешними без риска для контекста.


---

## Резюме

В этой лекции мы научились использовать встроенные функции Python, определять собственные функции, познакомились с объектом
"ничто" и понятием процедуры. Также мы теперь умеем вводить в работающую программу значения из консоли. 

## Задания

1. 