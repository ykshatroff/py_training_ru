Лекция 3. Функции в Python. Циклы. Логические типы данных
=========

### Значки, используемые в тексте

* :clock2: &mdash; отмечает, что высказывание не совсем верно, но будет уточнено позднее.
* :star: &mdash; выделяет определение нового понятия.
* :exclamation: &mdash; привлекает внимание к высказыванию.
* :point_up: &mdash; указывает на небольшое отступление от темы или уточнение.
* :bulb: &mdash; индикатор традиций и договорённостей. 
* :warning: &mdash; требуется осторожность: возможно, сложное высказывание.  

## Повторение материала предыдущей лекции

* *Утверждение "напечатать" (`print`)* &mdash; выводит значение выражения на стандартный вывод программы,
  начинается с ключевого слова `print`, за которым (отделённое пробелом) следует выражение. 
* *Управляющая структура* &mdash; конструкция, позволяющая изменять 
последовательность выполнения утверждений в программе.
* *Сложное утверждение* &mdash; утверждение, содержащее знак `:` и допускающее вложенные утверждения.
* *утверждение if-elif-else* &mdash; сложное утверждение, выполняющее только свою часть, соответствующую условию.
* *оператор сравнения* с сравнивает между собой два выражения, может использоваться в качестве условия.
* *блок кода* &mdash; набор утверждений, представляющий собой часть сложного утвержения и выделяемый отступом.
* *Утверждение "пропустить" (`pass`)* &mdash; ставится там, где необходим блок кода, но не требуется вычислений.

## Встроенные функции

Как мы помним, *операторы*  `+`, `-`, `=`, `==` и прочие, а также *ключевые слова* являются встроенными в язык. В отличие
  от переменных, которые обязательно объявить перед использованием, эти элементы доступны в любой момент. 
Кроме *ключевых слов*, в Python существуют и другие идентификаторы, которые не нужно объявлять. 

Одним из подобных элементов языка Python являются встроенные функции.

Как и в математике, :star: *функция* &mdash; это сущность, которая может принимать значения-параметры,
 оперировать над ними и возвращать результат. 
Возьмём, например, линейную функцию (в математической записи): 

    f(x) = kx + b

В этом примере функция `f` принимает значение `x` и возвращает результат `kx + b`, где `k` и `b` &mdash; константы. 
Если мы установим `k=2`, `b=3`, функция будет выглядеть как `f(x) = 2x + 3`. 
Подставив `x = 1`, получим результат `2*1 + 3 = 5`.

Как создать собственную функцию на Python, мы рассмотрим чуть ниже, 
а сейчас возьмём другую математическую функцию &mdash; абсолютной величины числа.
(Напомним, эта функция возвращает `x`, если он больше или равен 0, или `-х`, если он меньше нуля, то есть её результат 
&mdash; всегда неотрицательное число.)

Назовём эту функцию не `f`, a `abs` (от absolute).
В *математической нотации* это выглядит так:

    abs(x) = x, x >= 0; -x, x < 0

В Python такая функция является встроенной и называется ... `abs`. Каким же образом использовать эту функцию?  

Функции в Python вызываются почти так же, как выглядит их запись в математической нотации:
 
    abs(x)
    
Сначала идёт идентификатор функции, далее в круглых скобках через запятую перечисляются её *параметры* (или *аргументы*),
 количество которых определяется  
самой функцией (точнее, её определением, или *сигнатурой*). Аргументов может и не быть вообще.  
Функция `abs(x)`, например, принимает один аргумент.

:exclamation: Аргументом функции может быть любое выражение, при этом собственно вызов функции также является выражением.

:bulb: По соглашению, вызов функции в Python записывается так: между идентификатором функции и открывающей скобкой,
 а также скобками и выражением-аргументом (-ами) пробелы *не ставятся*. Если у функции нет аргументов, то пробелы
  между скобками также не ставятся.

Теперь мы можем написать в нашем файле: 

```python
print abs(2)
```
   
Мы увидим результат &mdash; `2`. Можем поэкспериментировать с выражениями: `abs(1 - 2)`, `abs(abs(5))`, `abs(5 - abs(5))`

### Возведение в степень: функция от двух аргументов и оператор `**`

Одна из простейших функций с двумя аргументами &mdash; возведение в степень `pow(x, y)`: 

```python
pow(5, 3)  # 125
```

возведёт `5` в степень `3`. Впрочем, обычно в Python
пользуются оператором возведения в степень: `**`

```python
5 ** 3  # Эквивалентно pow(5, 3)
```

Этот оператор имеет связывание сильнее, чем умножение и деление, но слабее, чем унарный *минус*. 
:point_up: При этом несколько последовательных операторов `**` вычисляются "справа налево":

```python
print 2 ** 2 ** 3  # 256
```

выведет `256` (2<sup>8</sup>), а не `64` (4<sup>3</sup>).

С помощью этих функции и оператора можно также считать корни: корень N-ной степени их `x` есть не что иное, 
как `x` в степени `1/N`.

:point_up: Главное преимущество функции `pow()` в том, что она умеет возводить в степень по модулю: например 
```python
pow(2, 8, 5)  # 1
```
возведёт 2 в 8-ю степень по модулю 5. Поэтому фактически эта функция может принимать как 2, 
так и 3 аргумента. 

### Ошибки с количеством аргументов. Функции с переменным числом аргументов

Если функция допускает какое-то известное количество аргументов, то при избытке или недостатке аргументов в вызове
функции возникнет ошибка:

    >>> abs()
    Traceback (most recent call last):
      File "<input>", line 1, in <module>
    TypeError: abs() takes exactly one argument (0 given)
    >>> pow(5, 10, 50, 100)
    Traceback (most recent call last):
      File "<input>", line 1, in <module>
    TypeError: pow expected at most 3 arguments, got 4
    
`TypeError` &mdash; ошибка типа &mdash; это исключение при несовпадении типа предоставленного значения с ожидаемым 
(в данном  случае под "типом" понимается состав аргументов)
и оно ещё будет в дальнейшем нам встречаться. 

Мы уже увидели, что есть функции, для которых количество аргументов зависит от контекста. Есть и такие функции, где
допускается разное число аргументов с одним и тем же контекстом.

В качесте примера функции с переменным числом аргументов приведём полезные функции `min()` и `max()`.
Они вычисляют соответственно минимальный и максимальный из переданных аргументов. 
Количество аргументов этих функций может быть любым, от двух :clock2: до 255.

```python
print min(5, 1, 2, 3)  # 1
print max(5, 1, 2, 3)  # 5
```    

:point_up: Функции `min()` и `max()` могут принимать и *один* аргумент, но им не может быть число: допустимые типы 
в случае единственного аргумента мы изучим позже.


## Функция ввода (чтения) с клавиатуры
 
Когда вы решали задачи для второй лекции, вы наверно устали менять значения для констант в тексте программы.
Одним из важнейших свойств программ является возможность не задавать все данные в коде заранее 
(или, как говорят, *хардкодить* &mdash; "жёстко кодировать"),
а обрабатывать пользовательский ввод. Для этого существует функция `input()`. При вызове без аргументов, она 
передаёт управление на консоль и предоставляет возможность пользователю ввести с клавиатуры выражение на Python.
 
Если мы запустим python в интерактивном режиме и просто введём 

    >>> input()
     
мы увидим приглашение вида

    >?
    
после которого можно начинать ввод выражения, заканчивая его клавишей `Ввод`. Введённое выражение будет вычислено и
выведено в консоль.

В программе мы можем использовать `input()` в утверждении присваивания: результат вычисления введённого выражения будет 
 присвоен переменной.

:exclamation: При использовании в программе приглашение `>?` не показывается, программа будет просто ждать ввода. 
 
Например, программа 

```python
x = input()
print x * x
```

сначала запросит ввод у пользователя, а затем
выведет результат пользовательского ввода, возведённый в квадрат. 


## Объявление функций

Python предоставляет некоторое количество встроенных функций, но наиболее ценна возможность создавать новые, иначе говоря,
*пользовательские (user-defined)* функции.
 
Пользовательская функция в Python является разновидностью управляющих структур. 
По сути, функция может включать в себя любое количество кода &mdash; выражений или утверждений, с тем, чтобы не повторять этот код
в разных местах, или чтобы логически группировать (структурировать) код.  

:point_up: В хорошем стиле программирования популярен принцип **DRY** &mdash; Don't repeat yourself &mdash; не повторяйся.
Этот принцип гласит, что если что-то в программе используется более чем один раз, этот факт негативно сказывается на
восприятии кода и подвергает программу опасности ошибок, связанных с тем, что поменяв что-то в одном месте, в другом аналогичном
поменять забыли. Заключение повторяющегося кода в функции решает, в частности, и подобные проблемы.

Для примера возьмём упомянутую выше линейную функцию `f(x) = kx + b` с параметрами `k=2, b=3`:

Объявление функции в Python &mdash; это управляющая конструкция, или *сложное утверждение*, которое выглядит примерно так:

```python
def linear_function(x):
    fx = 2 * x + 3
    return fx
```
    
Остановимся подробнее на элементах объявления функции: ключевое слово `def`, за которым через один (:bulb: по традиции) 
пробел следует *идентификатор* функции (в данном случае `linear_function`), 
по которому её можно вызывать в коде; за ним (:bulb: по традиции, без пробела) 
следует открывающая скобка, далее перечисляются имена *аргументов*; их замыкают
закрывающая скобка и знак `:`, после которого начинается *тело* функции, 
которое в данном случае состоит из двух утверждений.
  
:star: *Тело функции* &mdash; это блок кода, то есть одно или больше утверждений, выделенные отступом, 
либо :point_up: перечисленные в одной строке с разделителем `;` (точка с запятой). Последняя форма записи не является
хорошим стилем, но её может быть удобно использовать в интерактивном режиме.

:warning: В теле функции допускаются любые утверждения :clock2:, в частности утверждения присваивания, `print`, логические
конструкции `if-else` и т.п., даже вложенные объявления функций.   

:exclamation: Функции можно объявлять в любом месте программы :clock2:, где допустимо утверждение, 
:bulb: обычно их объявляют в начале программы, отделяя одно объявление от другого (и от прочего кода) двумя пустыми строками.  


### Утверждение "вернуть" (return-утверждение)

Чаще всего функция создаётся для того, чтобы *возвращать результат* &mdash; некое значение, которое вычисляется в теле функции. 
Для указания возвращаемого значения тело функции содержит `return`-утверждение. 

:star: *Утверждение `return`* &mdash; это команда интерпретатору "вернуть" вычисленное значение и завершить работу функции.

Утверждение `return` состоит из ключевого слова `return` и выражения, идущего за ним через один (:bulb: по традиции) пробел.
:point_up: Оно может встречаться только в теле функции. В любом другом месте программы наличие `return`-утверждения является
синтаксической ошибкой.


:exclamation: Обычно `return`-утверждение завершает блок кода (тело) функции, так как код, содержащийся в теле функции
после этого утверждения, не выполняется. Впрочем, в теле функции может быть любое количество `return`-утверждений. :clock2:
 
### Аргументы пользовательских функций
  
В приведённом нами примере у объявленной функции был один аргумент. На самом деле, количество аргументов у пользовательской
функции может быть любым: их может не быть вообще, либо очень много (:point_up: если совсем честно, 
Python допускает до 255 аргументов, но на практике вряд ли вам понадобится и десяток).

Названия аргументов следуют правилам именования переменных &mdash; фактически, аргумент и есть переменная. Только она доступна
лишь внутри объявляющей функции. 

Аргументы при объявлении функции перечисляются внутри скобок: так же, как и при вызове, отделяясь запятыми 
:bulb: с одним пробелом после запятой.


### Механизм выполнения кода в процессе вычисления функции

Итак, мы объявили нашу линейную функцию. Пришло время её протестировать:

```python
def linear_function(x):  # [1]
    fx = 2 * x + 3  # [2]
    return fx  # [3]
    

y = linear_function(5)  # [4]
print y  # [5]
```

При объявлении функции её тело *не выполняется*, только проверяется отсутствие в нём синтаксических ошибок.
Первой строкой программы, которая будет выполнена, является строка *[4]*, содержащая вызов функции. Чтобы вычислить
выражение, которым является вызов, выполнение программы перейдёт к первому утверждению тела вызываемой функции 
(другими словами, тело функции получит управление программой), 
на строке *[2]*, при этом переменной `x` &mdash; аргументу функции &mdash; 
будет присвоено значение, переданное в параметрах вызова, а именно `5`.  
Далее будут выполяться утверждения этого блока кода вплоть до первого утверждения `return`, которое у нас в строке *[3]*.
 
После обработки утверждения `return`, результат содержащегося в нём выражения будет передан в то место, 
где осуществлялся вызов &mdash;
в строку *[4]*, и это утверждение продолжит своё выполнение, заменив
выражение вызванной функции на её вычисленное значение.
и далее программа продолжит выполняться в той же последовательности, как и до вызова функции.
Итого, порядок выполнения строк будет таким: 4-2-3-(4)-5, где (4) значит, что утверждение получило управление повторно. 

Функция будет каждый раз получать управление при своём вызове, 
и каждый раз её тело будет вычисляться заново с указанными аргументами.

Добавим в нашу программу вычисление ещё одного значения `z`:

```python
def linear_function(x):  # [1]
    fx = 2 * x + 3  # [2]
    return fx  # [3]
    

y = linear_function(5)  # [4]
print y  # [5]
z = linear_function(10)  # [6]
print z  # [7]
```

Функция `linear_function()` будет вызвана дважды, и каждый раз её аргументу `x` будет присвоено новое значение.
Последовательность  выполнения строк кода будет 4-2-3-(4)-5-6-2-3-(6)-7.
 
###  Контексты функции

:star: То место кода, в котором вызывается функция, называется *контекстом вызова* (выполнения) функции. То есть, функция вызывается
 из контекста вызова и после вычисления возвращает значение в контекст вызова.

Выше мы упомянули, что функцию можно объявлять в любом месте программы. Это верно, но с небольшим уточнением:

:exclamation: Контексту вызова должно быть известно о вызываемой функции. То есть, функция должна быть объявлена до
своего первого использования.
  
:point_up: Теоретически, мы можем объявить несколько функций с одинаковыми именами. В таком случае, как и в случае с переменными,
каждое новое объявление полностью "перетирает" предыдущее, и контекст вызова будет пользоваться той функцией,
которая была объявлена последней. Но контекст вызова не умеет смотреть вперёд.

Помимо контекста вызова, существует ещё и *контекст объявления функции*.

:star: *Контекст объявления функции* &mdash; это тот блок кода (уровень вложенности), в котором функция была объявлена.
 
В случае нашей программы, контекст объявления &mdash; это сама программа, которая фактически является блоком кода верхнего уровня. 

Контекст объявления функции имеет важную особенность: он негласно передаёт в тело функции все известные ему идентификаторы.
Так, следуя хорошему стилю, мы можем объявить используемые нами литералы `2` и `3` как *константы*, чтобы читателям
 программы было понятно их назначение:
 
 
```python
SLOPE_COEFFICIENT = 2  # [1]
OFFSET = 3  # [2]


def linear_function(x):  # [1]
    fx = SLOPE_COEFFICIENT * x + OFFSET  # [2]
    return fx  # [3]


y = linear_function(5)  # [6] вызов функции
print y  # [7] выведет 13
```

Из примера видно, что тело функции может использовать объявленные в контексте объявления константы `SLOPE_COEFFICIENT` 
и `OFFSET`. 

:warning: Важный нюанс: хотя мы объявили константы *перед* объявлением использующей их функции, этого делать необязательно,
главное чтобы они находились на том же уровне вложенности кода. Но данные константы должны быть уже доступны *в контексте вызова*. 
Это происходит потому, что объявленные в *контексте объявления* идентификаторы передаются функции 
(происходит связывание их со значениями) в *момент вызова*.

Впрочем, всё-таки более удобно иметь дело с уже объявленными ранее идентификаторами.

Также если одна объявленная вами функция хочет обратиться к другой, также объявленной вами, нет необходимости
(хотя так и более очевидно) объявлять их поочерёдно: все функции, объявленные в одном контексте (в одном блоке кода),
доступны для вызова изнутри друг друга.

В пример этого, напишем общую линейную функцию с тремя аргументами и вызовем её из уже описанной линейной функции:
 
```python
def linear_function(x):
    fx = generic_linear_function(x, SLOPE_COEFFICIENT, OFFSET)
    return fx


def generic_linear_function(x, k, b):
    fx = k * x + b
    return fx


SLOPE_COEFFICIENT = 2
OFFSET = 3

y = linear_function(5)
print y
```
Данная программа выполнится успешно, несмотря на, казалось бы, обратный порядок объявления.  Если же переместить
объявление констант в самый конец программы, после вызова, мы получим ошибку:

    NameError: global name 'SLOPE_COEFFICIENT' is not defined
    
Имя `SLOPE_COEFFICIENT` не определено.

### Область видимости

Переменные и другие идентификаторы, объявленные внутри функций, не видны ни её контексту объявления, ни контексту вызова.
Это относится и к аргументам: они принимают переданные им при вызове значения только на время работы функции. 
То есть, если в теле функции объявить переменную, уже
существующую снаружи функции, или задекларировать у неё аргумент с уже использованным снаружи именем, то 
:warning: значение наружной переменной *никак не изменится*, а если такой переменной снаружи не было, она и не создастся.

Это правило называется :star: правилом *области видимости*.


```python
x = 1
k = 5
b = 8
 
def linear_function(k, b):
    x = 10
    y = k * x + b
    return y


print linear_function(2, 3)  # -> 13

print x  # 10
print k  # 5
print b  # 8
print y  # -> NameError ...
```

В результате присваивания переменной `x` значения `10` внутри функции, 
была создана совершенно новая переменная (*локальная* для функции), не влияющая на `x`
из первой строки. Переменные `k` и `b`, имена которых совпали с аргументами функции, также не поменяли своего значения
после её вызова. (Если аргументу явно присвоить новое значение внутри функции, то он ожидаемо примет это значение
до конца выполнения функции или до следующего присваивания.)
 
То же самое произошло и с `y`: локальная для функции переменная не "просочилась" в контекст 
и, при выполнении программы, в последней строке произошла ошибка *NameError: переменная `y` не определена*.

Таким образом, имена аргументов и внутренних переменных функции могут совпадать с внешними без риска для контекста. 

### Пара слов об идентификаторах

:bulb: По общепринятому соглашению, функции в Python именуются в стиле *Snake case*, то есть 
их названия состоят из строчных латинских букв и цифр от 0 до 9, при этом символ подчёркивания несёт смысл словоразделителя.

Переменные и функции могут называться одинаково, поэтому надо следить, чтобы их названия не совпадали. 
Впрочем, если вы будете следовать приведённому ниже совету, у вас такого не произойдёт.  

Очень важно правильно называть функции так, чтобы они отражали смысл своего существования (то, что они вычисляют).
Предпочтительно давать функциям названия в виде глагола в начальной форме с объектом-дополнением: 
`calculate_square` &mdash; вычислить квадрат, `make_float` &mdash; сделать вещественным, либо 
`convert_to_float` &mdash; конвертировать в вещественное: в аналогичных случаях часто используются
 выражения вида `to_float`, и т.п. Об исключениях, которые всё же существуют, мы будем особо сообщать.
 
:bulb: Переменные с идентификаторами вида `SLOPE_COEFFICIENT`, то есть записанные в заглавном регистре слова, 
с разделителями-символами подчёркивания, считаются *константами*. 
Фактически они выделяются только записью идентификатора. 
Они объявляются (им присваивается значение) один раз и далее только используются в выражениях.
:point_up: Фактически они не являются таковыми, то есть им можно присвоить и новое значение, но этого не рекомендуется делать,
так как это будет нарушать принятые соглашения и приводить как минимум к непониманию. Константы обычно именуются
существительными с определением: `SLOPE_COEFFICIENT` &mdash; коэффициент наклона, `BUTTON_COLOR` &mdash; цвет кнопки, 
 `REPETITIONS_COUNT` &mdash; количество повторений, и т.п.

Переменные обычно называют существительными (возможно, с определением) 
или причастиями: `color`, `current_color`, `data_ordering`. Для переменных название не так важно, потому что их использование
редко требуется за пределами небольшого участка кода. Функции и константы же могут использоваться в сотнях разных мест.

Говорят, что самое сложное в написании программ &mdash; это придумывать правильные названия переменным и функциям. 
Это недалеко от истины. В хороших программах грамотно названные сущности дают достаточно информации о происходящем, 
чтобы можно было не комментировать код. Помните правило "не повторяйся"? Можно не писать коммемнтарии о коде, 
когда всё очевидно из названий.
 
### Процедуры. Объект `None`

Довольно часто бывает, что нам не нужно значение, возвращаемое из функции. Например, мы хотим только вывести в консоль
значение аргумента. В этом случае мы можем просто не использовать присваивание значения &mdash; то есть, вызвать функцию
как выражение. Возвращаемое ею значение будет проигнорировано: 

```python
def print_value(x):
    print x
    return 304958309  # первое значение, пришедшее в голову. Всё равно игнорируется. 


print_value(10)  # значение, возвращаемое функцией, игнорируется 
```

Однако возникает вопрос, какое значение возвращать? А вдруг случайно кто-то возьмёт и присвоит это значение переменной,
 и там будет абракадабра? На этот случай предусмотрен специальный объект, который так и называется &mdash; "ничто": `None`.
Он встроен в язык Python, и является зарезервированным идентификатором: попытка присвоить значение объекту `None` вызовет
 синтаксическую ошибку. В то же время допустимо присвоить переменной значение `None`.

:star: *Объект `None`* &mdash; это специальная сущность, указывающая на отсутствие определённого значения. 

:point_up: Объект `None` не равен ни одному другому значению. В общем он ведёт себя аналогично  `null` в С, Java, Javascript. 

:exclamation: Если в теле функции отсутствует утверждение `return`, то функция автоматически возвращает объект `None`.
То же самое произойдёт, если утверждение `return` имеется, но не получит управление (не вычислится), например вследствие 
условной конструкции, внутри которой оно указано.


```python
def print_value(x):
    print x


print_value(10)  # выведет 10 
y = print_value(10)  # снова выведет 10
print y  # выведет None
```
Впрочем, можно и явно написать `return None`, результат будет такой же. Разница в том, какой смысл вкладывается 
в возвращаемое значение.   

:star: Функция, не возвращающая значения явно, по-другому называется *процедурой*. В приведённом выше примере,
функция `print_value(x)` является процедурой.

Самой простой процедурой является функция, содержащая одно лишь утверждение `pass`:

```python
def do_nothing():
    pass
```

Она часто называется *заглушкой*. Где можно использовать такую функцию? На самом деле, в дальнейшем окажется, что такие
случаи бывают, а для начала это просто сигнал о том, что эта функция есть, но ещё не готова.

:point_up: Если в интерактивном интерпретаторе ввести выражение, результат которого `None`, интрепретатор просто переведёт
на следующую строку:

    >>> x = None
    >>> x
    >>>

---

## Резюме

В этой лекции мы научились использовать встроенные функции Python,  
определять собственные функции, познакомились с объектом
"ничто" и понятием процедуры. Также мы теперь умеем вводить в работающую программу значения из консоли. 

## Задания

*Небольшая рекомендация:* 
сохраняйте все написанные вами программы в папки с названиями по номеру лекции, в файлы с 
названиями, содержащими номер задания, например `lect_3/program1.py`. Они вам ещё пригодятся.  



1. Модифицировать программу из задания 2 к прошлой лекции 
   (скопируйте и сохраните в новый файл), которая вместо заданного заранее `x`
   принимает значение с клавиатуры.
   
   Модифицировать программу из задания 3 к прошлой лекции, которая вместо заданных заранее `x` и `y`
   принимает значения с клавиатуры. 
   
2. Написать программу, которая запрашивает ввод 4 числовых значений: `a`, `b`, `c`, `d`,
   возводит `a` в степень `b` и `c` в степень `d`, вычисляет максимум из полученных двух
    значений и выводит его в консоль.
   
   *Проверка:*
    
   * a=3, b=6, c=4, d=5:  1024
   * a=32, b=0.2, c=27, d=1/3.0:  3.0

3. Написать программу с функцией, которая принимает два аргумента `x`, `y` и возвращает остаток от целочисленного 
   деления `x` на `y`. Обработать случай `y = 0`, чтобы не возникало ошибки деления на 0. Чтобы делитель и делимое были
    целыми числами, необходимо использовать встроенную функцию `round(x)`, которая округляет число-аргумент до ближайшего целого.
   (Формула вычисления остатка от деления: `rem = x - (x / y * y)`)
    
   В основной части программы запрашивать ввод двух значений и выводить результат вычисления функции. 

4. Написать программу с функцией, которая конвертирует валюту по заданному курсу: функция
   принимает 1 аргумент &mdash; вещественное число: сумму в рублях; курс задаётся константой; значение округляется
   до 2 знаков после запятой с помощью той же встроенной функции `round(x, N)`, но с двумя аргументами, где *N* &mdash;
   количество знаков после запятой.

   В основной части программы запрашивать ввод значения &mdash; суммы в рублях, и выводить результат вычисления функции. 
