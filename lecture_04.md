Лекция 4. Циклы. Операторы присваивания с модификацией. Логический тип данных. Строки 
=========

### Значки, используемые в тексте

* :clock2: &mdash; отмечает, что высказывание не совсем верно, но будет уточнено позднее.
* :star: &mdash; выделяет определение нового понятия.
* :exclamation: &mdash; привлекает внимание к высказыванию.
* :point_up: &mdash; указывает на небольшое отступление от темы или уточнение.
* :bulb: &mdash; индикатор традиций и договорённостей. 
* :warning: &mdash; требуется осторожность: возможно, сложное высказывание.  

### Повторение терминов из третьей лекции

* *Функция* &mdash; это сущность, которая может принимать значения и возвращать результат.   
* *Функция `input()`* &mdash; это функция, запрашивающая ввод значения пользователем.   
* *Функции `abs(x)`, `min(x, y, ...)`, `max(x, y, ...)`, `round(x)` и `round(x, N)`*     &mdash; 
  встроенные функции в Python.
* *Пользовательские функции* &mdash; функции, объявляемые в программах с использованием ключевого слова `def`.
* *Контекст вызова* и *контекст объявления* функции &mdash; состояние программы в моменты соответственно вызова и
  объявления функции, то есть набор доступных функции переменных: в качестве аргументов или для использования в теле функции.
* *Утверждение `return`* &mdash; утверждение, указывающее интерпретатору на окончание выполнения функции и необходимость 
  возврата предоставленного выражения в контекст вызова в качестве результата.
* *Константы* &mdash; переменные, объявляемые один раз и используемые в дальнейшем только для вычислений, имеющие
  специальное оформление идентификаторов в заглавном регистре.
* *Объект `None` ("ничто")*  &mdash; объект, возвращаемый функцией в случае отсутствия в ней утверждения `return` или
  неполучения им управления (программа до него "не дошла").
  

## Циклический алгоритм. Цикл `while`

Мы с вами уже не раз встречались с заданиями, в которых требовалось повторить одно и то же действие несколько раз:
ввести несколько значений, сравнить несколько чисел (найти максимум или минимум), посчитать значения, соответствующие условию. 
Часто подобные операции однотипны и повторяются по определённому шаблону.
Например, умножение на N &mdash; это повторение операции сложения N раз, 
возведение в степень &mdash; это повторение операции умножения, а
посчитать количество чётных чисел из набора заданных  &mdash; это повторение операции 
присваивания с увеличением счётчика на единицу, если число делится на 2 без остатка.

Попробуем записать это в псевдокоде:

    счётчик = 0
    ВВЕДЁМ переменную Х
    ЕСЛИ Х чётное: 
        увеличим счётчик на 1
    ВВЕДЁМ переменную Y
    ЕСЛИ Y чётное: 
        увеличим счётчик на 1
    и так далее...
 
У нас уже есть возможность управлять течением программы, используя условные конструкции. 
Но они хороши тогда, когда точно известно количество проверок и условий. В случае, если мы хотим задать количество повторений
извне, мы не можем просто скопировать условную конструкцию N раз. Нам хотелось бы видеть что-то подобное:  

    счётчик = 0
    ВВЕДЁМ количество_проверок 
    количество_пройденных_проверок = 0
    ПОКА количество_пройденных_проверок не больше количество_проверок:
        ВВЕДЁМ переменную Х
        ЕСЛИ Х чётное: 
            увеличим счётчик на 1
        количество_пройденных_проверок увеличим на 1


В Python эта возможность является элементарной и обеспечивается конструкцией `while` &mdash; "пока", и выглядит она так:

    while УСЛОВИЕ: БЛОК_КОДА
   
:star: Конструкция цикла `while` &mdash; это *сложное утверждение*, указывающее на повторение 
содержащегося в нём блока кода до тех пор, пока выполняется
заданное в ней условие. 

Смысл данной конструкции такой: проверяется  _УСЛОВИЕ_, если оно верно, то выполняется _БЛОК_КОДА_ (*тело цикла*), в котором 
изменяются используемые в условии значения; затем снова проверяется условие, и так до тех пор, пока оно верно;
затем управление переходит к следующему утверждению.
Если условие изначально неверно, то весь _БЛОК_КОДА_ пропускается.

Продемонстрируем цикл на следующем задании: вывести числа от 1 до 10.

```python
x = 1  # переменная, содержащая выводимое число, она же счётчик выполнений цикла
while x <= 10:
    print x
    x = x + 1  # увеличиваем счётчик
```

Эта конструкция очень похожа на `if`-конструкцию, с той лишь разницей, что блок кода в `if`-утверждении выполняется 0 или 1 раз,
а в `while`-утверждении &mdash; 0 или более раз. 

:star: Одно выполнение цикла называется *итерацией*, таким образом цикл состоит из 0 или более итераций.

:point_up: Количество выполнений блока кода в циклах `while` не ограничено, и нужно быть 
крайне внимательным и не допускать, чтобы выражение
 в условии выполнялось всегда: это приведёт к бесконечному циклу и является распространённой ошибкой. Обязательно 
 проверяйте, чтобы условие менялось в каждой итерации или хотя бы периодически.


## Операторы присваивания "на месте" (in-place). Оператор остатка от деления по модулю `%`

В приведённом примере мы увеличиваем счётчик выполнений цикла в каждой итерации с помощью оператора присваивания.
Такой приём настолько распространён в программировании, и в частности в Python, что для сокращения кода (и заодно
во избежание повторений названий переменных) имеется специальный набор операторов *присваивания с модификацией на месте*, 
одним из них является сложение с модификацией:

    x += y

эквивалентно 

    x = x + y
    
Также существуют вычитание с модификацией: `x -= y`, умножение: `x *= y`, деление: `x /= y`, 
и возведение в степень: `x **= y`.
 
В задании к прошлой лекции мы вычисляли *остаток от деления по модулю*. Впрочем, в Python уже есть и такой оператор:
 
    x % y
    
означает остаток от деления `x` на `y` (как целочисленного, так и вещественного). И для него есть аналогичный оператор
присваивания "на месте":

    x %= y
    
:point_up: В других ЯП типа С, помимо указанных операторов, существуют и операторы ++ и -- (увеличить и уменьшить на 1).
В Python такого оператора намеренно нет, чтобы всегда сохранять явность операнда.

## Логический тип данных

Теперь мы можем записать наш пример по подсчёту чётных чисел на Python во всей красе. :warning: Для краткости (и также ради 
демонстрации техники работы с циклами) мы не будем вводить отдельный счётчик цикла, а сразу уменьшать введённую нами
переменную *количество_проверок*, пока она не достигнет 0:

```python
inputs_count = input()  # вводим счётчик выполнений цикла, он же - количество вводимых значений
evens_count = 0  # счётчик чётных чисел среди введённых

while inputs_count > 0:
    x = input()  # вводим число
    if x % 2 == 0:  # число чётное?
        evens_count += 1  # увеличиваем счётчик чётных чисел
    inputs_count -= 1  # уменьшаем счётчик цикла

print evens_count
```

Если мы введём первое число 5, то условие `inputs_count > 0` в утверждении `while` проверится 6 раз, 
из которых 6-й раз оно будет неверно.
Также мы проверяем в теле цикла условие `x % 2 == 0`, и если оно верно применительно к введённому в текущей итерации `x`,
 увеличиваем счётчик чётных чисел.
 
Мы уже не раз использовали слова "верно" или "неверно" применительно к условиям, и как оказывается, в Python существует
тип данных специально для таких понятий. 

Мы можем выразить "счётчик чётных чисел" простым языком: 
количество чётных чисел во множестве равно *сумме раз*, когда число чётное. Если обозначить результат проверки каждого числа
 за 1 ("раз"), если оно чётное (условие "верно") и 0, есло оно нечётное ("неверно"), сумма этих результатов и будет искомым счётчикомю 
Например,  для множества чисел 2, 3, 5, 8, 13,  это будет суммой 1 + 0 + 0 + 1 + 0 = 2.

И действительно, в Python существует логический тип данных (так называемый *Булевский* или "булев" тип, по имени изобретателя логической
алгебры), который состоит из двух значений, являющихся встроенными в язык объектами
`True` (*истинно*, верно) и `False` (*ложно*, неверно). При этом,  `True` &mdash; это "надстройка" над 1, 
а  `False`  &mdash; "надстройка" над 0. Что это значит, мы узнаем буквально через пару строк. 
 
:exclamation: Результатом любой операции сравнения является булев объект `True`  или `False`. 

Записав в интерактивном python условное выражение, мы увидим именно *булев* результат:
  
    >>> 4 % 2 == 0
    True
    >>> 5 % 2 == 0
    False

А вот и объяснение про магическую надстройку:

    >>> False == 0
    True
    >>> True == 1
    True
    >>> True + True
    2
    >>> True + False
    1

Фактически, мы можем использовать `True`  и `False` вместо 1 и 0. Конечно, там, где это уместно. В нашем примере мы спокойно
можем заменить `if`-конструкцию на одно утверждение присваивания с модификацией:

```python
inputs_count = input()  # вводим счётчик выполнений цикла, он же - количество вводимых значений
evens_count = 0  # счётчик чётных чисел среди введённых

while inputs_count > 0:
    x = input()  # вводим число
    evens_count += (x % 2 == 0)  # увеличиваем счётчик чётных чисел на результат сравнения (1 или 0)
    inputs_count -= 1  # уменьшаем счётчик цикла

print evens_count
```

Скобки вокруг выражения проверки условия чётности не обязательны, но в подобных случаях их принято ставить для лучшей читаемости.

:point_up: И всё-таки так писать не рекомендую, ибо эта форма записи часто не интуитивна и сбивает с толку.   

## Приведение выражений к булеву типу

Мы выяснили, что можно использовать `True` вместо 1, `False` вместо 0. Можно ли наоборот? Да, можно:

```python
if 1:
    print 1  # -> 1

if 0:
    print 0  # не выполнится
```

То есть, в блоке УСЛОВИЕ в `if`-конструкции допускается число. С 0 и 1 всё понятно -- будут использоваться их булевы эквиваленты,
а что же с другими числами? Ответ прост: любое число, кроме 0, считается в контексте "УСЛОВИЕ" истинным. Этот ответ выводится из 
булевой алгебры, а именно логических операций И и ИЛИ, которые являются аналогами соответственно умножения и сложения.

:point_up: Для доказательства, давайте немного вспомним алгебру логики. Это нам пригодится чуть позже. Итак, у нас существует
выражения, которые могут иметь значение ИСТИНА или ЛОЖЬ, и три определённых над ними операции: И, ИЛИ, НЕ. Таким образом,
 например, НЕ ИСТИНА = ЛОЖЬ, ИСТИНА ИЛИ ЛОЖЬ = ИСТИНА, ЛОЖЬ И ИСТИНА = ЛОЖЬ и т.п. (Подробнее см. [Алгебра логики].) 

Возьмём два положительных числа A и B. Обозначим, в контексте доказательства, логическую операцию *И* как `*`, а операцию *ИЛИ* как `+`.
* `А * В` всегда ненулевое (выражение `А И В` истинно, если истинны и А, и В), в то же время `А * 0 == В * 0 == 0`.
* `А + В` равно нулю только если `А == В == 0 `(`А ИЛИ В` истинно, если хоть одно из А и В истинно),
 в то же время `А + 0 == А`, `В + 0 == В`. 
 
Таким образом, для булевой алгебры значение `False` то же самое, что число 0 для арифметики, а любое другое положительное
 число аналогично значению `True`.
 
На отрицательные числа распространяется то же правило -- любое ненулевое отрицательное число истинно. Это следует из
того, что арифметическое понятие знака для логического выражения не имеет смысла и не меняет значения его истинности. 
(Существующая логическая
операция отрицания, *НЕ*, арифметически может быть эквивалентна выражению `1 - A` для А из множества логических значений 0 и 1.)
 
:exclamation: Помимо чисел, мы уже знаем ещё один тип данных, к которому принадлежит объект `None`. Так вот, объект `None`
 в логическом контексте эквивалентен значению `False`.


## Логические операторы

В Python, неудивительно, поддерживается и набор логических операторов, которые мы перечислили выше, только
 записываются они на английском языке. Эти операторы: И -- `and`, ИЛИ -- `or`, НЕ -- `not` с такой же ассоциативностью, то есть
`and` и `or` принимают по 2 операнда, а `not` является унарным правоассоциативным (относится к операнду справа от себя).

Их используют для того, чтобы в одном блоке УСЛОВИЕ можно было указать несколько выражений.

Порядок вычисления таков: ***


## Функции-типы данных

Условия в Python имеют одну важную особенность: если не привести выражение явно к булеву типу, то оно всегда сохраняет свой тип.
 Даже если мы используем логические операторы, 
 значение выражения `2 and 3` будет целым числом 3.
  

## Строки

Мы с вами уже, пожалуй, достаточно хорошо знаем арифметику и различные элементы синтаксиса Python, чтобы перейти к изучению строк.
Строковый тип данных


## Ссылки

[Алгебра логики]: https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%B5%D0%B1%D1%80%D0%B0_%D0%BB%D0%BE%D0%B3%D0%B8%D0%BA%D0%B8

