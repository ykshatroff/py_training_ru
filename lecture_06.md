Лекция 6. Объекты. Атрибуты. Методы 
=========


### Значки, используемые в тексте

* :clock2: &mdash; отмечает, что высказывание не совсем верно, но будет уточнено позднее.
* :star: &mdash; выделяет определение нового понятия.
* :exclamation: &mdash; привлекает внимание к высказыванию.
* :point_up: &mdash; указывает на небольшое отступление от темы или уточнение.
* :bulb: &mdash; индикатор традиций и договорённостей. 
* :warning: &mdash; требуется осторожность: возможно, сложное высказывание.  

### Повторение терминов из пяттой лекции

* *Контейнеры* &mdash; объекты, содержащие в себе другие объекты (элементы).
* *Изменяемые контейнеры* &mdash; контейнерные объекты, содержимое которых может меняться.
* *Строки* &mdash; неизменяемые контейнерные объекты, элементом которых является символ или байт.
* *Строки unicode* &mdash; строки, элементом которых является символ unicode.
* *Списки* &mdash; изменяемые контейнерные объекты, элементом которых может быть любой объект.
* *Утверждение (цикл) `for`* &mdash; утверждение, указывающее интерпретатору на необходимость выполнения содержащегося
  в нём блока кода последовательно для всех элементов контейнера.
* *Утверждение `assert`* &mdash; утверждение, которое при невыполнении передаваемого ему условия вызывает ошибку.

## Объекты

До сих пор мы довольно часто сталкивались со словом "объект", но не вдавались в подробности.
Пришло время познакомиться с объектами поближе.

Объект в Python -- это любая сущность данных, включая числа, строки, списки. Синтаксически, объект -- 
это результат вычисления выражения.
 
Объект  в Python имеет два главных свойства: тип и идентичность.

## Тип объекта

Тип объекта -- это тип данных, сущностью которого является объект, и его можно узнать с помощью функции
`type()`: 

```python
print type(1)  # <type 'int'>
print type("a")  # <type 'str'>
print type(u"a")  # <type 'unicode'>
print type([])  # <type 'list'>
```
Мы видим, что названия типов объектов совпадают с именами функций преобразования к этому типу. На самом деле,
"функции преобразования" -- это не просто функции, а *конструкторы* типов: функция `int()` *создаёт*
объект типа `int`, и так далее. Примечательно, что если мы попробуем вывести "значение" конструктора, 
мы увидим то же самое, что и при выводе типа:

```python
print int  # <type 'int'>
```

Какой практической пользой это обладает? Мы получаем возможность узнать тип объекта -- 
переменной, литерала, выражения -- и с помощью простого оператора равенства сравнить его с одним из известных
нам типов:

```python
assert type(1) == int
assert type("a") == str
```

:clock2: Если углубиться в исследование типов, окажется, что конструктор также является объектом типа `type`, а собственно
`type` -- это также конструктор, который имеет тот же тип `type`, и он является "корневым" типом всей системы типов
Python.

```python
print type(int)  # <type 'type'>
print type(type)  # <type 'type'>
```
Уже скоро мы увидим, как осуществляется создание объектов и какую роль в этом играет конструктор типа.

## Идентичность объекта. Оператор `is`

Все объекты в Python имеют уникальный идентификатор, который позволяет отличить один объект от другого, даже
если у них одинаковые значения и тип данных. Этот идентификатор можно получить с помощью функции `id()`:
```python
print id(1)  # 39043416
print id("a")  # 140225581035472
```
Идентификатор является 32- или 64-бытным целым числом и действует на время жизни программы 
(то есть меняется при каждом её перезапуске).

Если идентификаторы объектов равны, это гарантирует, что объект один и тот же. Что нам это даёт? 
Помните про изменяемые и неизменяемые объекты? -- Так вот, проверить, изменился ли сам объект (контейнер) 
или был создан новый, можно с помощью этой функции.
   
```python
x = 1
y = x
assert id(x) == id(y)
y += 1
assert id(x) != id(y)

x = [1]
y = x
assert id(x) == id(y)
y += [2]
assert id(x) == id(y)
```

Впрочем, такое написание довольно ненаглядно и предполагает теоретические обоснования (которые приведены выше), а
так как эта проверка важна и используется часто, для неё создан специальный оператор `is`, который
 полностью аналогичен примеру выше: он проверяет идентичность
объектов-операндов и возвращает `True`, если оба выражения указывают на один объект, иначе `False`.

```python
x = 1
y = x
assert x is y
y += 1
assert not x is y
assert x is not y

x = [1]
y = x
assert x is y
y += [2]
assert x is y
```
Да, и у данного оператора есть противоположный: `x is not y` эквивалентно `not (x is y)`, но более естественно.
 
## Атрибуты объектов

Самое интересное ждёт нас впереди, буквально отсюда.
Атрибуты -- это то, что делает Python таким гибким, в одно и то же время простым и сложным языком.
Можно сказать, что понятие атрибута является краеугольным камнем Python.

Атрибут объекта -- это другой объект, связанный с первым специальным отношением членства. 
Примерно как и элемент контейнера, который мы можем получить по индексу, атрибут имеет имя, по которому мы
можем получить его от связанного объекта. По отношению к объекту, являющемуся атрибутом, 
имя атрибута -- это (ещё один) вариант имени объекта, наряду с переменной.

Список атрибутов объекта можно получить с помощью функции `dir()`:
```python
print dir(1)  # ['__abs__', '__add__', '__and__', '__class__', ....
```
Мы увидим достаточно много имён атрибутов.

Атрибуты объекта зависят прежде всего от типа объекта, но объекты некоторых типов позволяют также
*устанавливать* атрибуты. Об этом чуть позже, сначала посмотрим, как нам их *получить*.

Получить атрибут объекта по имени можно с помощью оператора `.` (он применим к любым видам объектов, кроме
численных литералов и является одним из наиболее приоритетных операторов в Python вместе 
с операторами взятия элемента по индексу, среза и вызова функции):
```python
x = 1  # к атрибутам численных литералов нельзя обращаться напрямую 
print dir(x)  # ['__abs__', '__add__', '__and__', '__class__', .... 'imag', 'real']
print x.real  # 1  # действительная часть комплексного числа
print x.imag  # 0  # мнимая часть комплексного числа
print x.__class__  # <type 'int'>
print dir("a")  # [... 'lower' ... 'upper' ... ]
print "a".__class__  # <type 'str'>
print "a".lower  # <built-in method lower of str object at 0x7fce067435f8>
```

Как можно заметить, атрибут `X.__class__` содержит указатель на тип объекта и его значение идентично значению
 функции `type(X)`. Но пожалуй более важно обратить внимание на последнюю строку примера:
  что же это за "built-in method"? " 

## Методы

Так как атрибут -- это потенциально любой объект, то Python не гарантирует его тип. Как и в случае с переменными,
тип атрибута определяется динамически. Одним из наиболее частых типов атрибутов является функция.  
Однако для функций, специально предназначенных для работы с объектами, обычно употребляют слово "метод".

:star: *Метод* -- это специализированный тип функции, который существует только в виде атрибута объекта и при вызове 
неявно получает в аргументах этот объект. 

Таким образом, код внутри метода всегда знает, к какому объекту он относится.
Эта привязка метода к объекту отражена и в выводе `print "a".lower`: `< ...str object at 0x7fce067435f8>` -- это как раз
число в 16-ричном формате, равное `id("a")`.

Вызов метода записывается так же, как и вызов функции, используя оператор "круглые скобки" с перечислением
всех аргументов, кроме собственно объекта (так как, повторим, он будет передан интерпретатором без записи).

Рассмотрим поближе некоторые методы. Метод `.lower()` является стандартным атрибутом объектов строковых типов (str, unicode)
и преобразует строку в строчный регистр букв. Таким же стандартным атрибутом этих типов является и противоположный
по назначению метод `.upper()`.
 
```python
print "A".lower  # <built-in method lower of str object at 0x7fce067435f8>
assert "A".lower() == "a"
print "b".upper  # <built-in method upper of str object at 0x7fce06743620>
assert "b".upper() == "B"
```

:point_up: В дальнейшем, чтобы отделять методы от функций, а также указывать, атрибутами объектов каких типов они являются,
 будем использовать запись вида `TYPE.METHOD()`, где `TYPE` -- имя типа, а `METHOD` -- имя атрибута. 
 Например `str.lower()`, `str.upper()`.
 
## Методы строковых типов

Кроме упомянутых `str.lower()` и `str.upper()`, у строковых объектов есть ещё уйма полезных методов. 
Перечислим некоторые из них:

* `str.count(X)` -- подсчитывает кол-во вхождений подстроки Х в строку-объект, возвращает целое число;
* `str.startswith(X)` -- возвращает булев результат, начинается ли строка-объект с Х;
* `str.endswith(X)` -- возвращает булев результат, оканчивается ли строка-объект на Х;
* `str.index(X)` -- возвращает номер символа, начиная с которого в строке идёт подстрока Х, в случае если подстрока не
  найдена -- вызывает исключение ValueError;
* `str.find(X)` -- то же самое, что и `str.index(X)`, только вместо исключения возвращает -1;
* `str.decode(X)` -- конвертирует простую строку с указанной кодировкой Х в строку unicode, наиболее
  употребительная кодировка -- `'utf-8'`;
* `unicode.encode(X)` -- обратное преобразование: 
  конвертирует unicode строку в простую строку с указанной кодировкой Х, наиболее
  употребительная кодировка -- `'utf-8'`.

 
## Методы списков и кортежей

Пара методов списков очень похожа на методы строк, и они же применимы и к кортежам:

* `list.count(X)` -- подсчитывает кол-во вхождений элемента Х в список-объект, возвращает целое число;
* `list.index(X)` -- возвращает номер элемента Х в списке, в случае если элемент не входи в список -- 
  вызывает исключение ValueError.


Для списков, как изменяемых объектов, 
одним из наиболее употребительных методов является `list.append()`, который принимает один 
аргумент и добавляет его в конец текущего объекта-списка (модифицируя сам объект).  

```python
x = []
x.append(1)
assert x == [1]
```

Обратным методом является метод `list.pop()`, который при вызове без аргументов возвращает последний 
элемент списка и убирает его, укорачивая список на 1; с одним аргументом, берётся (и удаляется) 
не последний элемент, а элемент, чей индекс равен этому аргументу.

Полезен метод `list.remove(X)`, который находит элемент Х и удаляет его из списка. 

Все эти методы при отсутствии элемента или индекса в списке вызывают исключение ValueError.

## Общие атрибуты, не являющиеся методами

У объектов встроенных типов не так много простых, не функциональных атрибутов. 
Это прежде всего уже упомянутый `__class__`, комплексные части числа. 

Для типов (объектов, являющихся типами: `int`, `str` ...) актуален атрибут `__name__`, который равен строковому
представлению типа:

```python
assert int.__name__ == "int"
assert str.__name__ == "str"
assert type("a").__name__ == "a".__class__.__name__
```

Однако у объектов из модулей, и у пользовательских объектов, может быть великое разнообразие атрибутов, методов,
способов их определения, получения и присваивания. Продолжение следует :)

## Резюме

Сегодня мы добрались до понятия сущности, или объекта, и узнали, что он обладает атрибутами, которые могут быть
любыми объектами, в том числе вызываемы как функции, такие атрибуты называются методами.
Мы узнали некоторые атрибуты и методы объектов встренных типов.