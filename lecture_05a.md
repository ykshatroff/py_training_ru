Лекция 5а. Продолжение лекции 5: строки unicode. Изменяемость объектов   
=========

### Значки, используемые в тексте

* :clock2: &mdash; отмечает, что высказывание не совсем верно, но будет уточнено позднее.
* :star: &mdash; выделяет определение нового понятия.
* :exclamation: &mdash; привлекает внимание к высказыванию.
* :point_up: &mdash; указывает на небольшое отступление от темы или уточнение.
* :bulb: &mdash; индикатор традиций и договорённостей. 
* :warning: &mdash; требуется осторожность: возможно, сложное высказывание.
  
## Строки unicode

У строк в Python есть один неприятный нюанс: для многобайтовых кодировок, к которым относится и используемая обычно
utf-8, каждый символ строки, не относящийся к базовой части ASCII (ASCII -- это однобайтовая кодировка, содержащая 128
сивмолов, среди которых буквы английского алфавита, арабские цифры и большинство знаков препинания, пробел, перевод строки),
будет записан двумя или более *байтами*. В то же время элементом такой строки является именно *байт*. Например,

```python
# coding: utf-8
assert len("яблоко") == 12  # а не 6, как можно было бы предположить
assert "яблоко"[0] == '\xd1'  # то есть символ с кодом 0xD1 == 209, а не "я", как можно было бы предположить
```
 
Таким образом, работа с не-ASCII символами была бы крайне неудобной. Для решения этой проблемы существует
специальный строковый тип unicode ("юникод"), который предоставляет возможность *посимвольной* работы со строками. 
Литералы типа юникод записываются как обычная строка (в любом виде кавычек), предварённая буквой u (без пробелов):

```python
# coding: utf-8
"apple"  # обычная строка
u"apple"  # строка юникод
u"яблоко"  # строка юникод
assert u"я" in u"яблоко" 
assert u"яблоко"[0] == u"я" 
```

Все операции, допустимые для обычных строк, действуют и для строк юникод.

:clock2: В Python 3 "обычными" являются как раз строки юникод, а байтовые строки имеют собственный тип bytes. Это одно
из главных отличий третьего Python от второго.

При этом строки юникод в какой-то мере совместимы с обычными: так, если обычная строка содержит только ASCII-символы, 
 то её можно сравнивать со сторками unicode, добавлять друг к другу -- 
 тип результата этих операций будет юникод -- и проверять наличие подстроки:
   
```python
# coding: utf-8
assert "apple" == u"apple"
assert "apple" + u"apple" == u"appleapple"
assert "app" in u"apple"
```
Если же хоть один символ в обычной строке -- не-ASCII, то получим ошибку UnicodeDecodeError:
```python
# coding: utf-8
assert "apple" + u"яблоко" == u"appleяблоко"
u"apple" + "яблоко"  # UnicodeDecodeError ...
```


## Функции `ord()` и `chr()`

Для преобразования символов в строке из текстового вида в числовое представление, равное индексу символа в кодировке,
  используется функция `ord()`. Для обратного преобразования -- функция `chr()` для обычных строк и функция `unichr()` 
  для строк юникод.
  
Эти функции можно использовать для того, чтобы увидеть числовое представление строки в байтах или, например, получить
следующий/предыдущий символ. Функции работают только со строками длиной в один элемент: один байт для обычных строк, символ
юникод для строк юникод.


```python
# coding: utf-8
assert ord("a") == 97
assert chr(97) == "a"
assert chr(ord("a") + 1) == "b"
assert chr(209) + chr(143) == "я"
assert ord(u"я") == 1103
assert unichr(ord(u"я") - 1) == u"ю"
```
Однако, надо иметь в виду, что порядок символов определяется кодировкой и не в каждой кодировке следующий по алфавиту символ
будет иметь численное значение, большее на 1. 


## Изменяемые и неизменяемые объекты

Одно из основных отличий списка от строк -- то, что данные в списке могут быть разных типов. Но у списка есть ещё одно крайне
важное отличие: его можно *модифицировать*.

Операция взятия элемента по индексу для строки и списка работает одинаково: возвращает элемент. Но для списка также
 определена и операция "установить (присвоить) элемент по индексу", и записывается она совершенно логично -- как присваивание значения
 элементу списка с индексом:
 
```python
a_list = [1, 2, 3]
assert a_list[1] == 2
a_list[1] = 4  # присваивание
assert a_list[1] == 4
```

При выполнении подобной операции, объект-список остаётся тем же, но элемент списка меняется. Можно привести следующую аналогию:
возьмём лист бумаги, это будет объект.
При инициализации (объявлении) списке мы "запишем на лист бумаги" элементы, при изменении элемента их состав на листе поменяется,
 но сам лист останется тот же (разница только, что этот "лист" бесконечен). В строке же мы не можем изменять элементы.

Таким же образом, операция присваивания "на месте" со списком работает несколько по-иному, чем со строкой. 
Если в результате применения операции
к переменной, содержащей строку, формировалась *новая строка*, дополненная слагаемым аргументом 
(и новый объект-результат записывался обратно в переменную), то список *модифицируется*
непосредственно, то есть новый объект списка не создаётся, а значения второго аргумента просто дописываются в этот список.

До списков мы имели дело только с *неизменяемыми*
 типами данных: скажем, оператор сложения "на месте" над числами просто записывает в переменную новое число.
 
Какие последствия это имеет? Продемонстрируем на следующем примере:
 
```python
x = [1, 3, 5] 
y = x
x += [7, 9]
print x, y  # [1, 3, 5, 7, 9] [1, 3, 5, 7, 9]
```

мы увидели, что *обе* переменных-списка стали содержать одинаковые элементы. На самом деле, это и есть *один и тот же*
объект-список, просто у него два разных *имени*.

Концепция *изменяемости* в Python имеет крайне важное значение. Практический смысл этого понятия пока нам не так очевиден, но
уже очень скоро мы будем иметь с ним дело. 

## Кортежи (tuple)

У списков есть и неизменяемый аналог &mdash; кортежи (`tuple`). Они вводятся литералами `()` (круглые скобки), внутри
которых, как и в списках, через запятую перечисляются содержащиеся данные. 

```python
(1, 3, 5) 
("", False, None)
```

:exclamation: Для того, чтобы отличить кортеж с одним элементом от просто выражения в скобках, после первого и единственного
элемента кортежа ставится запятая; таким образом, *любое выражение* с примыкающей запятой, заключённое в скобки --
 это кортеж из одного элемента:

```python
print (1)  # выражение, значение которого - число 1
print (1, )  # кортеж с единственным элементом 1
print (input())  # выражение
print (input(), )  # кортеж
```


## Ввод литералов с помощью `input()`

Функция `input()` оказывается не простая: с её помощью можно вводить любые литералы, в частности списки, кортежи и строки.
Только одно условие: они должны быть записаны синтаксически корректно.

```python
x = input('Input "apple": ')  # введём "apple" - именно так, с кавычками
assert x == "apple"
```
Если ввести "apple" без кавычек, функция `input()` будет рассматривать это слово как идентификатор переменной, которая
не объявлена и вызовет ошибку NameError.

## Конвертация типов контейнеров

В прошлой лекции мы встретили функции-конверторы типов данных `bool()`, `int()` и т.п. Объекты-контейнеры тоже
можно конвертировать между собой, хотя и есть некоторые моменты, заслуживающие отдельного внимания.

Для конвертации объекта в список существует функция `list()`, принимающая один аргумент-контейнер. 
Без аргументов она просто вернёт пустой список, то есть `list() == []`.
Если аргумент &mdash; кортеж, то будет создан список с теми же объектами и в том же порядке, как в кортеже. Если объект &mdash; строка,
 то строка будет разбита по символам и список будет состоять из элементов-однобуквенных строк. Если объект &mdash; список,
 то будет создан список &mdash; полная копия оригинального (часто эту функцию и используют с этой целью, ведь, как мы помним,
 список изменяемый, и чтобы сохранять оригинальное значение, создаются копии).
 
```python
list((1, 2, 3))  # [1, 2, 3]
list([1, 2, 3])  # [1, 2, 3]
list("asd")  # ["a", "s", "d"]
```
 
Почти так же работает и функция `tuple()` &mdash; создаёт кортеж с элементами из списка или кортежа, или с односимвольными строками
из строки. Она всегда создаёт копию кортежа, так как кортеж неизменяем.

Функция `str()` же, в отличие от предыдущих, просто превращает объект в строку, подходящую для вывода в консоль,
 максимально напоминающую литерал:

```python
assert str([1, 2, 3]) == "[1, 2, 3]"  
assert str((1, 2, 3)) == "(1, 2, 3)"  
```

Из строки функция `str()` также сделает копию строки.

Для юникод-строк полностью аналогично функции `str()` работает `unicode()`.


## Практическое использование кортежей и списков

Одно из самых частых использований кортежей &mdash; в операциях интерполяции строк. Если левый аргумент-строка
содержит несколько "плейсхолдеров" вида `%s`, а правый аргумент является кортежем, то все эти плейсхолдеры по порядку
заменяются на элементы кортежа:

```python
print "This is a %s number %s" % ("test", 1)  # This is a test number 1 
```
Если количество плейсхолдеров не совпадает с количеством элементов в кортеже, будет ошибка `TypeError`.

Если в строке ровно 1 плейсхолдер, то вторым аргументом можно указать как непосредственный объект, так и кортеж из одного
 объекта, и это единственно возможный вариант, если таким объектом является собственно кортеж: 
 
```python
print "This is a tuple: %s " % (("test", 1), )  # This is a tuple: (test, 1) 
print "This is an ERROR: %s " % ("test", 1)  # TypeError: ...
```

Литералы кортежей можно спутать с аргументами функций,
но обычно они появляются в разных контекстах. Впрочем, аргументом функции может быть и объект типа "кортеж", в таком
случае приходится немного усложнять запись вызова функции. 

Вспомним уже рассмотренные нами в третьей лекции функции `min()`, `max()`: мы говорили, что они принимают от двух и более
простых (скалярных) аргументов. Так вот, если передать этим функциям *один* аргумент, которым будет *кортеж или список*,
то они вычислят минимум или максимум из его элементов. И обратите внимание на то, как записывается вызов функции
с аргументом-литералом кортежа.

```python
list_of_numbers = [1, 3, 7, 4, 5]
assert max(list_of_numbers) == 7
tuple_of_numbers = (1, 3, 7, 4, 5)
assert max(tuple_of_numbers) == 7
assert max((1, 3, 7, 4, 5)) == 7
```
Для корректной передачи литерала кортежа в качестве аргумента, мы пишем две пары скобок: одни обозначают вызов функции,
вторые &mdash; объявление литерала. Всё логично.


## Маленькие хитрости print

Утверждение `print` может не только выводить по одному результату выражения в строке.
 
Если нужно расположить несколько результатов в одной строке, как нам уже известно, мы можем перечислить их через запятую
и они появятся в одной строке с разделением пробелами. Однако следующий `print` опять начнёт с новой строки -- потому, что
`print` обычно добавляет в конце невидимый символ "перевод строки". Чтобы сказать ему не делать этого, нужно
просто добавить запятую после всех выводимых выражений:

```python
print "on line 1" 
print "on line 2", "also on line 2",
print "on line 2, too" 
print "on line 3" 
```

Чтобы, наоборот, заставить `print` начать с новой строки, можно вставить пустое утверждение `print`:  
```python
print "on line 1", "also on line 1",
print 
print "on line 2" 
```
