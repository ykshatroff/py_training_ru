Лекция 9. Тип данных "словарь" (`dict`). Расширенный синтаксис для аргументов функций 
=========


### Значки, используемые в тексте

* :clock2: &mdash; отмечает, что высказывание не совсем верно, но будет уточнено позднее.
* :star: &mdash; выделяет определение нового понятия.
* :exclamation: &mdash; привлекает внимание к высказыванию.
* :point_up: &mdash; указывает на небольшое отступление от темы или уточнение.
* :bulb: &mdash; индикатор традиций и договорённостей. 
* :warning: &mdash; требуется осторожность: возможно, сложное высказывание.  

## Тип данных "словарь"

### Структуры типа "карта"

Вспомним материал из предыдущих лекций, а именно про контейнерные типы данных.

Условно к контейнерным типам можно отнести любой объект, поскольку у него есть атрибуты; однако, для ясности, контейнером
  будем считать только тот тип данных, который позволяет доступ к элементам.

К текущей лекции нам известно о трёх разновидностях контейнерных типов данных: строки (в том числе строки `unicode`),
 список и кортеж. Все эти типы являются упорядоченными и поэтому обычно называются *последовательностями* (*sequence*).
 
В то же время, такой тип данных, как файл,
сам по себе не является контейнером, но предоставляет *интерфейс* последовательности 
(то есть ведёт себя как последовательность, с точки зрения цикла `for`).

Последовательность задаётся однозначным соотношением "индекс->элемент", 
то есть каждому индексу соответствует ровно 1 элемент. При этом на индексы накладываются два ограничения: во-первых,
это целое число, во-вторых, индексы последовательны (отсюда -- последовательность). 

Однако бывают ситуации, когда нам необходимо хранить однозначные соответствия не только чисел к элементам, 
но и других объектов. Пример из реальной жизни: 
у дома есть адрес, выражающийся сложной структурой "Город, район, улица, номер", или у сотрудника с именем и фамилией 
есть номер телефона, должность и т.п.

Для подобных структур с однозначным отношением идентификатора ("ключа") к объекту ("значению") существует термин "карта",
в английском `mapping`.

"Карты" чаще всего являются неупорядоченными нетипизированными структурами, и именно таким типом данных является в Python
тип `dict`, он же словарь.

### Синтаксис типа данных "словарь"

Словарь является *изменяемым контейнером*, содержащим любые объекты, при этом доступ к ним осуществляется по *ключу*, 
которым может
быть объект нечислового типа, например строка или кортеж. 

Литерал словаря записывается как `{key: value, key2: value2}`, где key -- объект-ключ, value -- объект-значение.
 Словарь может быть пустым, в таком случае его объявление выглядит просто как `{}`.
 
```python
empty_dict_example = {}
employee = {'rank': 'manager', 'birthday': [1980,12,12], ("Name", "Last Name"): {'phone': '+70001234567'}}

assert employee['rank'] == 'manager'
assert employee[("Name", "Last Name")] == {'phone': '+70001234567'}
employee['department'] = "Finance"
assert employee['department'] == "Finance"
```

### Ключи словаря в деталях

Из примера видно, что ключами словаря могут быть строки и кортежи. Какие ещё типы данных можно использовать? Ответ
довольно сложный. 

Во-первых, можно использовать все "скалярные" типы данных, то есть числа, логические типы и объект None. 

Во-вторых, объекты неизменяемых типов данных, чьи элементы также неизменяемы: под это подходят строки
обоих типов, а также кортежи, состоящие из неизмеяемых элементов.

В-третьих, любые "хешируемые" объекты. Хеш -- это специальная встроенная функция `hash()`, которая преобразует объект в числовое
представление. Для этого объект должен соответствовать некоторым условиям, но главное -- проверить, хешируемый ли объект,
можно с помощью этой функции: если она вернёт число -- то да, объект можно использовать как ключ. В противном случае
функция вызовет ошибку `TypeError` "Нехешируемый тип данных".

Естественно, под одним ключом в словаре может находиться только один объект. При записи значения под существующим ключом,
существующее значение будет перезаписано новым:
 
```python
employee = {'rank': 'manager', 'birthday': [1980,12,12], ("Name", "Last Name"): {'phone': '+70001234567'}}

assert employee['rank'] == 'manager'
employee['rank'] = "CTO"
assert employee['rank'] == "CTO"
```

### Полезные методы объекта "словарь"

Можно получить все ключи в словаре в виде списка, методом `dict.keys()`, и все значения в словаре в виде списка методом
`dict.values()`.
Также можно получить в виде списка кортежей пары ключ-значение методом `dict.items()`.

```python
employee = {'rank': 'manager', 'birthday': [1980,12,12], ("Name", "Last Name"): {'phone': '+70001234567'}}

assert sorted(employee.keys()) == ['birthday', 'rank', ('Name', 'Last Name')]
assert sorted(employee.values()) == [{'phone': '+70001234567'}, [1980, 12, 12], 'manager']
assert sorted(employee.items()) == [
        ('birthday', [1980, 12, 12]), 
        ('rank', 'manager'), 
        (('Name', 'Last Name'), {'phone': '+70001234567'})
        ]
```

Для проверки результатов мы используем функцию `sorted()`. Это следствие неупорядоченности словаря.

### Неупорядоченность

Что на практике значит неупорядоченность? В условиях, когда объекты ключей и значений могут быть разных типов,
их порядок в общем случае лишён смысла. Под порядком можно также иметь в виду разные вещи: порядок добавления
  ключей в словарь, алфавитный порядок (для строк), числовой; порядок ключей или порядок значений... 
  Да и главная цель словаря -- предоставить значение по ключу -- не связана
 никак с количеством и порядком ключей. 
 
В общем случае гарантировать, что даже идентичный набор пар "ключ-значение"
будет представлен в одном порядке, Python не может. 
  
Для хранения порядка ключей в случае необходимости можно использовать внешний список.
 
### Наличие и отсутствие ключа в словаре. Удаление ключа из словаря

Если мы обратимся к отсутствующему ключу, то как и в случае с последовательностью, это является ошибкой. Только для словаря
типом ошибки будет `KeyError`, с указанием ключа.

```python
test = {}
test['key']  # => KeyError: key
```

Для проверки наличия ключа можно использовать оператор `in`, который работает аналогично другим контейнерам:

```python
test = {'key': 'value'}
assert 'key' in test
assert 'other_key' not in test
```

Удалить существующий ключ можно с помощью утверждения `del`:  

```python
test = {'key': 'value'}
del test['key']
assert 'key' not in test
assert test == {}
```

## Применение словарей

Словари -- один из наиболее часто применяемых типов данных в Python. Многие структуры, такие как метаданные файла (имя файла,
размер и тп) возвращаются в виде словарей.
 
Самым простым, пожалуй, и довольно важным видом применения словарей являются именованные плейсхолдеры в 
известном нам операторе подстановки для строк: `"%s" % value` -- символы %s называются плейсхолдерами.
 Мы знаем, что можно использовать несколько плейсхолдеров, если для подстановки передавать кортеж 
 с соответствующим количеством элементов. Однако именованные плейсхолдеры дают ещё и возможность использовать
 одно и то же значение несколько раз, а выглядят они как `%(name)s`, где `name` -- строковое значение, соответствующее
 ключу передаваемого словаря.

 
```python
text = "Hello from %(company)s, %(user)s! %(company)s is glad you are with us!"
data = {'user': 'UserName', 'company': 'MegaCompany, Inc.'}
assert text % data == 'Hello from MegaCompany, Inc., UserName! MegaCompany, Inc. is glad you are with us!'
```

В случае с последовательными плейсхолдерами нам пришлось бы передавать значение для компании дважды, да и риск
запутаться возрастает.

## Расширенные аргументы функций

До сих пор мы передавали аргументы функциям (как при их объявлении, так и при вызове) последовательно.
Однако функции позволяют использовать и другие способы передачи аргументов.


### Передача именованных аргументов

Предположим, у нас есть функция `f(x, y)`, которая просто вычисляет разность x и y.

```python
def f(x, y):
    return x - y
```

Самый простой способ вызвать её как `f(2, 1)`, но вдруг мы забыли порядок объявления аргументов и вместо 2, 1
 передали 1, 2 ? Чтобы точно быть уверенными в том, что мы именно этим аргументам хотим передать именно такие значения,
 можно записать `f(x=2, y=1)`, то есть после имени переменной-аргумента указывать его значение через знак равенства.
 

```python
def f(x, y):
    return x - y
    
assert f(x=2, y=1) == 1
assert f(y=1, x=2) == 1
```
