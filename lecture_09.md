Лекция 9. Тип данных "словарь" (`dict`). Расширенный синтаксис для аргументов функций 
=========


### Значки, используемые в тексте

* :clock2: &mdash; отмечает, что высказывание не совсем верно, но будет уточнено позднее.
* :star: &mdash; выделяет определение нового понятия.
* :exclamation: &mdash; привлекает внимание к высказыванию.
* :point_up: &mdash; указывает на небольшое отступление от темы или уточнение.
* :bulb: &mdash; индикатор традиций и договорённостей. 
* :warning: &mdash; требуется осторожность: возможно, сложное высказывание.  

## Тип данных "словарь"

### Структуры типа "карта"

Вспомним материал из предыдущих лекций, а именно про контейнерные типы данных.

Условно к контейнерным типам можно отнести любой объект, поскольку у него есть атрибуты; однако, для ясности, контейнером
  будем считать только тот тип данных, который позволяет доступ к элементам.

К текущей лекции нам известно о трёх разновидностях контейнерных типов данных: строки (в том числе строки `unicode`),
 список и кортеж. Все эти типы являются упорядоченными и поэтому обычно называются *последовательностями* (*sequence*).
 
В то же время, такой тип данных, как файл,
сам по себе не является контейнером, но предоставляет *интерфейс* последовательности 
(то есть ведёт себя как последовательность, с точки зрения цикла `for`).

Последовательность задаётся однозначным соотношением "индекс->элемент", 
то есть каждому индексу соответствует ровно 1 элемент. При этом на индексы накладываются два ограничения: во-первых,
это целое число, во-вторых, индексы последовательны (отсюда &mdash; последовательность). 

Однако бывают ситуации, когда нам необходимо хранить однозначные соответствия не только чисел к элементам, 
но и других объектов. Пример из реальной жизни: 
у дома есть адрес, выражающийся сложной структурой "Город, район, улица, номер", или у сотрудника с именем и фамилией 
есть номер телефона, должность и т.п.

Для подобных структур с однозначным отношением идентификатора ("ключа") к объекту ("значению") существует термин "карта",
в английском `mapping`.

"Карты" чаще всего являются неупорядоченными нетипизированными структурами, и именно таким типом данных является в Python
тип `dict`, он же словарь.

### Синтаксис типа данных "словарь"

:star: Словарь является *изменяемым контейнером*, содержащим любые объекты, при этом доступ к ним осуществляется по *ключу*, 
которым может быть объект нечислового типа, например строка или кортеж. 

Литерал словаря записывается как `{key: value, key2: value2}`, где key &mdash; объект-ключ, value &mdash; объект-значение.
 Словарь может быть пустым, в таком случае его объявление выглядит просто как `{}`.
 
```python
empty_dict_example = {}
employee = {'rank': 'manager', 'birthday': [1980,12,12], ("Name", "Last Name"): {'phone': '+70001234567'}}

assert employee['rank'] == 'manager'
assert employee[("Name", "Last Name")] == {'phone': '+70001234567'}
employee['department'] = "Finance"
assert employee['department'] == "Finance"
```

### Ключи словаря в деталях

Из примера видно, что ключами словаря могут быть строки и кортежи. Какие ещё типы данных можно использовать? Ответ
довольно сложный. 

Во-первых, можно использовать все "скалярные" типы данных, то есть числа, логические типы и объект None. 

Во-вторых, объекты неизменяемых типов данных, чьи элементы также неизменяемы: под это подходят строки
обоих типов, а также кортежи, состоящие из неизмеяемых элементов.

В-третьих, любые "хешируемые" объекты. Хеш &mdash; это специальная встроенная функция `hash()`, которая преобразует объект в числовое
представление. Для этого объект должен соответствовать некоторым условиям, но главное &mdash; проверить, хешируемый ли объект,
можно с помощью этой функции: если она вернёт число &mdash; то да, объект можно использовать как ключ. В противном случае
функция вызовет ошибку `TypeError` "Нехешируемый тип данных".

Естественно, под одним ключом в словаре может находиться только один объект. При записи значения под существующим ключом,
существующее значение будет перезаписано новым:
 
```python
employee = {'rank': 'manager', 'birthday': [1980,12,12], ("Name", "Last Name"): {'phone': '+70001234567'}}

assert employee['rank'] == 'manager'
employee['rank'] = "CTO"
assert employee['rank'] == "CTO"
```

### Полезные методы объекта "словарь"

Можно получить все ключи в словаре в виде списка, методом `dict.keys()`, и все значения в словаре в виде списка методом
`dict.values()`.
Также можно получить в виде списка кортежей пары ключ-значение методом `dict.items()`.

```python
employee = {'rank': 'manager', 'birthday': [1980,12,12], ("Name", "Last Name"): {'phone': '+70001234567'}}

assert sorted(employee.keys()) == ['birthday', 'rank', ('Name', 'Last Name')]
assert sorted(employee.values()) == [{'phone': '+70001234567'}, [1980, 12, 12], 'manager']
assert sorted(employee.items()) == [
        ('birthday', [1980, 12, 12]), 
        ('rank', 'manager'), 
        (('Name', 'Last Name'), {'phone': '+70001234567'})
        ]
```

Для проверки результатов мы используем функцию `sorted()`. Это следствие неупорядоченности словаря.

### Неупорядоченность

Что на практике значит неупорядоченность? В условиях, когда объекты ключей и значений могут быть разных типов,
их порядок в общем случае лишён смысла. Под порядком можно также иметь в виду разные вещи: порядок добавления
  ключей в словарь, алфавитный порядок (для строк), числовой; порядок ключей или порядок значений... 
  Да и главная цель словаря &mdash; предоставить значение по ключу &mdash; не связана
 никак с количеством и порядком ключей. 
 
В общем случае гарантировать, что даже идентичный набор пар "ключ-значение"
будет представлен в одном порядке, Python не может. 
  
Для хранения порядка ключей в случае необходимости можно использовать внешний список.

## Операции со словарями. Сравнение словарей

Сравнение словарей в Python 2 может быть как проверкой на равенство, так и на порядок (больше-меньше), что в принципе
мало осмысленно с учётом неупорядоченности словаря, поэтому рассматривать его мы не будем, а в Python 3
 допускается только проверка равенства.

Правило равенства словарей заключается в том, что словарь равен другому словарю с точно таким же набором ключей и значений.
Порядок ожидаемо не имеет значения.
 
```python
assert {} == {}
assert {'key': 'value'} == {'key': 'value'}
assert {'key': 'value'} != {'other_key': 'value'}
assert {'key': 'value'} != {'key': 'other_value'}
assert {'a': 1, 'b': 2} == {'b': 2, 'a': 1}
```
 
В отличие от других контейнерных типов, словари не позволяют выполнять над собой "арифметические" операции вида `+` или `*`.
(Для последовательностей &mdash; `list`, `str`, `tuple` &mdash; операция `*` означает мультипликацию, то есть "размножение" данной
последовательности, например `assert "asd" * 2 == "asdasd"`, `assert ["a", "b"] * 2 == ["a", "b", "a", "b"]`)

Впрочем, существуют две допустимых операции со словарями. 

### Наличие и отсутствие ключа в словаре. Удаление ключа из словаря

Если мы обратимся к отсутствующему ключу, то как и в случае с последовательностью, это является ошибкой. Только для словаря
типом ошибки будет `KeyError`, с указанием ключа.

```python
test = {}
test['key']  # => KeyError: key
```

Для проверки наличия ключа можно использовать оператор `in`, который работает аналогично другим контейнерам:

```python
test = {'key': 'value'}
assert 'key' in test
assert 'other_key' not in test
```

Удалить существующий ключ можно с помощью утверждения `del`:  

```python
test = {'key': 'value'}
del test['key']
assert 'key' not in test
assert test == {}
```

(Кстати, это утверждение работает и для списков, удаляя элемент из списка по индексу).

## Применение словарей

Словари &mdash; один из наиболее часто применяемых типов данных в Python. Многие структуры, такие как метаданные файла (имя файла,
размер и тп) возвращаются в виде словарей.
 
Самым простым, пожалуй, и довольно важным видом применения словарей являются именованные плейсхолдеры в 
известном нам операторе подстановки для строк: `"%s" % value` &mdash; символы %s называются плейсхолдерами.
 Мы знаем, что можно использовать несколько плейсхолдеров, если для подстановки передавать кортеж 
 с соответствующим количеством элементов. Однако именованные плейсхолдеры дают ещё и возможность использовать
 одно и то же значение несколько раз, а выглядят они как `%(name)s`, где `name` &mdash; строковое значение, соответствующее
 ключу передаваемого словаря.

 
```python
text = "Hello from %(company)s, %(user)s! %(company)s is glad you are with us!"
data = {'user': 'UserName', 'company': 'MegaCompany, Inc.'}
assert text % data == 'Hello from MegaCompany, Inc., UserName! MegaCompany, Inc. is glad you are with us!'
```

В случае с последовательными плейсхолдерами нам пришлось бы передавать значение для компании дважды, да и риск
запутаться возрастает.

## Расширенные аргументы функций

До сих пор мы передавали аргументы функциям (как при их объявлении, так и при вызове) последовательно.
Однако функции позволяют использовать и другие способы передачи аргументов.


### Передача именованных аргументов

Предположим, у нас есть функция `f(x, y)`, которая просто вычисляет разность x и y.

```python
def f(x, y):
    return x - y
```

Самый простой способ вызвать её как `f(2, 1)`, но вдруг мы забыли порядок объявления аргументов и вместо 2, 1
передали 1, 2 ? Чтобы точно быть уверенными в том, что мы именно этим аргументам хотим передать именно такие значения,
можно записать `f(x=2, y=1)`, то есть после имени переменной-аргумента указывать его значение через знак равенства. 
Для именованных аргументов последовательность их перечисления не имеет значения.

```python
def f(x, y):
    return x - y
    
assert f(x=2, y=1) == 1
assert f(y=1, x=2) == 1
```

:point_up: По традиции между именем аргумента, знаком равенства и значением пробелы не ставятся, в отличие от ситуации
с присваиванием. 

Именованные аргументы можно сочетать с неименованными (порядковыми). Основное правило при этом &mdash; записывать именованные
аргументы после порядковых (нарушение этого правила &mdash; синтаксическая ошибка, `SyntaxError`). При этом порядковые
аргументы распределяются вначале, и затем оставшиеся нераспределёнными аргументы ищутся среди именованных. Таким образом,
первым аргументом будет первый порядковый, вторым &mdash; второй порядковый (если есть), и т.п., и использовать их 
среди именованных не допускается.

```python
def f(x, y, z):
    return x - y - z
    
assert f(3, y=1, z=2) == 0 
assert f(3, z=2, y=1) == 0
f(3, 2, x=1)  # TypeError: f() got multiple values for keyword argument 'x'
```

### Аргументы по умолчанию

Мы не раз встречали встроенные функции, принимающие разное количество аргументов. Например, функция округления `round()`
 принимает один или два аргумента. Причём вызов `round()` с одним аргументом фактически эквивалентен вызову с вторым аргументом,
 равным 0:
 
```python
assert round(5.4321) == round(5.4321, 0) == 5.0
```

Такое поведение бывает удобным во многих случаях и основывается на передаче аргументам значений по умолчанию, указываемых 
*при объявлении функции*, используя синтаксис именованных аргументов: 

```python
def f(x, y, z=0):
    return x - y - z
    
assert f(3, 2) == f(3, 2, 0) == f(3, 2, z=0) == 1  
assert f(3, 2, 1) == f(3, 2, z=1) == 0  
```

Как видно, аргумент, объявленный вместе со значением по умолчанию, можно просто опустить при вызове функции, 
и он автоматически получит своё значение. В остальном он ведёт себя как обычный аргумент &mdash; значение может быть взято
 как из последовательных, так и из именованных аргументов.
 
### Списочные и словарные аргументы
 
Ещё одним способом организовать обработку аргументов, не лимитированных названиями и количеством, является объявление
 функции как принимающей "списочные" и "словарные" наборы аргументов.
 
Рассмотрим функции `max()` и `min()`, которые принимают любое количество аргументов и, если аргумент один,
то рассматривают его как последовательность (`sequence`)  и производят вычисления внутри неё, а при наличии нескольких
аргументов производят вычисления среди них, рассматривая каждый как отдельный элемент. Реализация такого поведения в Python
элементарна. Так называемый "списочный" набор аргументов является списком (точнее, кортежем), формируемым из
всех порядковых значений, которые указаны при вызове функции и остались нераспределёнными, синтаксически этот
набор обозначается как знак `*` и имя переменной, которой будет присвоен этот набор, обычно это имя `args` 
(впрочем оно может быть любым допустимым для переменной именем).

```python
def f(*args):
    return args
        
assert f(1, 2, 3) == (1, 2, 3) 

def f2(x, y, *args):
    return args
        
assert f2(1, 2, 3) == (3, ) 
```

Списочный набор аргументов в объявлении функции может быть только один и находиться в конце перечня аргументов.

Аналогично списочному набору, позволяется организовать и "словарный набор" аргументов, в который
попадают все нераспределённые при вызове *именованные* аргументы, а словарным он является потому, что представляет
собой словарь (`dict`), ключом в котором является имя, а значением &mdash; переданное значение. Синтаксически это выглядит
 как два знака `*` и имя переменной, которой будет присвоен этот набор, обычно это имя `kwargs` или просто `kw`. 

```python
def f(**kwargs):
    return kwargs
        
assert f(a=1, b=2) == {'a': 1, 'b': 2} 

def f2(x, y, **kwargs):
    return kwargs
        
assert f2(x=1, y=2, z=3) == {'z': 3} 
```

Словарный набор при объявлении функции также должен замыкать список аргументов.

Списочный и словарный наборы также можно комбинировать, при этом сначала указывается списочный, затем словарный. 

```python
def f(*args, **kwargs):
    return [args, kwargs]
        
assert f(1, 2, 3, a=5, b=6) == [(1, 2, 3), {'a': 5, 'b': 6}] 
```

Необходимо заметить, что набор аргументов нельзя явно передать как единый аргумент, то есть запись вида
`f(args=[1,2,3])` вызовет ошибку вида "непредусмотренный именованный аргумент args".

Самое интересное &mdash; это то, что мы можем не только объявлять функции с такого рода наборами, но и передавать им аргументы
в аналогичном виде, независимо от того, как объявлена функция. Главное, чтобы последовательные аргументы 
распределялись соответственно значениям, указанным в передаваемом списочном наборе, а именованные соответствовали
именам. Синтаксически это организовано весьма похоже на объявления:

```python
def f(x, y, z):
    return [x, y, z]
       
args = [1, 2]
kwargs = {'z': 3}
assert f(*args, **kwargs) == [1, 2, 3] 
```

И, как логично предположить, в вызове функции можно комбинировать последовательные и именованные аргументы с наборами,
лишь бы наборы шли в конце аргументов. Если фунцкия принимает наборы, то ожидаемо "лишние" аргументы попадут в соответствующий набор.

Полностью порядок указания аргументов (и при вызове, и при объявлении функций) выглядит так:
* сперва последовательные аргументы,
* следом именованные,
* затем списочный набор,
* и замыкает словарный набор.

Благодаря наборам аргументов открываются возможности модифицировать перечень передаваемых функциям аргументов перед вызовом,
вместо того чтобы два раза записывать вызов одной и той же функции с разными аргументами.

Злоупотреблять этими возможностями не следует, предпочтительно всё же перечислять аргументы явно по порядку или по имени,
но в некоторых случаях альтернативы получились бы весьма громоздкими и неуклюжими.

## Резюме

## Задания 

[Следующая лекция](./lecture_10.md) [Оглавление](./README.md) [Предыдущая лекция](./lecture_08.md) 
