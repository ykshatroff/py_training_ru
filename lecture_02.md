Лекция 2. Ключевые слова. Комментарии. Управляющие структуры и блоки кода.
-------------------------------------------------------------------------

### Значки, используемые в тексте

* :clock2: &mdash; отмечает, что высказывание не совсем верно, но будет уточнено позднее.
* :star: &mdash; выделяет определение нового понятия.
* :exclamation: &mdash; привлекает внимание к высказыванию.
* :point_up: &mdash; указывает на небольшое отступление от темы или уточнение.
* :bulb: &mdash; индикатор традиций и договорённостей. 
* :warning: &mdash; требуется осторожность: возможно, сложное высказывание.  

### Повторение терминов из первой лекции

* *Литерал* &mdash; непосредственное значение, например, целое или дробное число;  
* *Переменная* &mdash; некий идентификатор, имеющий, но скрывающий своё непосредственное значение;    
* *Оператор* &mdash; элемент, указывающий на проведение определённой операции (сложения, умножения и т.п.) над операндами;  
* *Выражение* &mdash; последовательность литералов и/или переменных и/или операций над ними. Выражение вычисляется
  интерпретатором и возвращает результат. Выражение может также содержать операции над выражениями;
* *Утверждение* &mdash; законченная команда компьютеру, например вычисление выражения для вывода результата в консоль или для присваивания
  его переменной. Обычно заканчивается переводом строки (ВВОД, ENTER в интерпретаторе). В отличие от выражения, не имеет результата.
* *Исключение* &mdash; ошибка, возникающая при некорректном выражении или некорректных значениях выражения.  
  
#### Оператор изменения знака числа: `-`.

Как упоминалось в предыдущей лекции, мы можем вводить отрицательные числа так же, как и в математике, в виде литерала числа 
с предшествующим унарным оператором _минус_: `-2` . Точно так же мы можем изменить знак результата любого выражения, предварив его
оператором `-`.  

    >>> -2 

Таким же образом мы можем присвоить переменной `y` значение со знаком, противоположным значению (объявленной ранее) переменной `x`:
  
    >>> x = 2
    >>> y = -x
    >>> y
    -2
    
что выведет `-2`.


### Ключевые слова. Утверждение "напечатать" (print-statement)

До сих пор мы работали в интерактивном интерпретаторе. Пришло время создать нашу первую *программу*.
 
Что такое Python-программа? В общем случае программа &mdash; это набор команд для компьютера. 
В нашем курсе мы будем считать программой набор утверждений на Python, *записанный в файл*. 
Наличие файла с текстом программы (как говорят программисты, "**кодом**") является ключевым свойством программы. 
Оно отражается на поведении интерпретатора python:     

:exclamation: При выполнении программы из файла интерпретатор уже не выводит значения после каждого перевода строки.
 
Для вывода значения выражения в программе нужно использовать так называемый
*print-statement* (утверждение "напечатать" или "напечатай"). Оно выглядит как анлийское слово `print`, за которым через пробел следует
требуемое выражение: например,  `print 2` или `print 2 + 2`.

:bulb: Количество пробелов (один или несколько) после ключевого слова `print` для интерпретатора не важно, 
но по соглашению принято использовать один пробел.

Утверждение `print` можно использовать и в интерактивном интерпретаторе:

    >>> print 2
    2
    
Однако именно в программах его использование просто не имеет альтернативы ([NB 1](#nb_1)).
 
Давайте создадим файл с программой на Python (В PyCharm: _File -> New -> Python file_; 
либо можно использовать текстовый редактор типа Блокнот, но не какой-либо Office) 
с названием, например, `program1`.
(:point_up: Файл должен иметь расширение `.py`. В  PyCharm оно будет добавлено автоматически.) 

Напишем в нём одну строку (:point_up: при использовании текстового редактора необходимо сохранить файл!):

```python
print 2
```

Теперь можно :point_up: запустить эту программу (В PyCharm: _Run -> Run... -> &lt;Ввод>_; в командной строке &mdash; `python program1.py`) 
и в её выводе мы увидим `2`.

Слово `print` в составе данного утверждения &mdash; так называемое *ключевое слово*. 

:star: Ключевые слова являются идентификаторами,
которые встроены в язык Python и не требуют объявления (в отличие от переменных), при этом объявляемые переменные не могут
 носить имя, совпадающее с ключевыми словами.
 
:bulb: Ключевые слова в Python по традиции записываются в строчном регистре и являются тем или иным английским словом.

:point_up: Фактически, вычисление выражения справа от знаков `>>>` в интерактивном режиме

    >>> 2 + 2
    4

эквивалентно выполнению программы с содержанием

```python
print 2 + 2
```
    
&mdash; эта программа также выведет `4`.
    
### Содержание программы. Комментарии

Как мы уже сказали, программа &mdash; это набор утверждений на Python.
Утверждения в программе записываются по одному в строке ([NB 2](#nb_2)) и выполняются в общем случае последовательно 
в порядке записи :clock2: .

:point_up: Во многих других языках программирования для разделения команд используется символ `;`, но хорошим стилем считается
записывать по одной команде в строке. В данном случае Python предлагает использовать хороший стиль в качестве корректного
синтаксиса, делая ненужными лишние символы.

:exclamation: Строки текста программы, в которых нет ни одного утверждения, никак :clock2: не влияют на её результат. 

Таковыми считаются:
* пустые строки (не содержащие никаких символов или состоящие из одних пробелов или табуляции),
* строки, содержащие (за исключением пробелов) только *комментарии*.

:star: Комментарий &mdash; это часть программы, которая 
никак не влияет на её выполнение, то есть игнорируется интерпретатором, но при этом (обычно) несёт смысл для человека.

Комментарием считается любая строка, начинающаяся с символа `#`, либо имеющая между началом строки и этим символом только пробелы 
(_полнострочный комментарий_).
Также комментарием является часть строки, начиная с символа `#`, идущего после любого выражения
 (опять же, пробелы между выражением и символом `#` не имеют значения).
 
:bulb: По соглашению, однако, если комментарий начинается после утверждения или выражения, 
его отделяют от выражения ровно двумя пробелами. Полнострочный комментарий обычно относится к идущему за ним 
в следующей строке утверждению. Если это не так, то
между строкой (строками) комментария и следующим за ним(-и) утверждением вставляется пустая строка.


Мы часто будем использовать комментарии в наших занятиях. Примеры комментариев в программе:

```python
# Так может выглядеть простейшая программа на Python. 
# Это общий комментарий к программе.

# ниже следует print-утверждение.
print 2 + 2  # оно выведет 4
```

:exclamation: В программах на Python 2 есть такая вещь, как *необходимый специальный комментарий*. Для того, чтобы Python 2 
корректно работал с русским языком в тексте программы, **первой строкой** должен идти комментарий с указанием кодировки, 
который выглядит так, как в примере ниже. Первую строку из этого примера нужно вставлять в каждую программу для Python 2. 
(:point_up: В PyCharm можно вписать её в шаблон файла, и она будет добавляться автоматически.)  

```python
# coding: utf-8

# Так может выглядеть простейшая программа на Python. 
# Это общий комментарий к программе.

# ниже следует print-утверждение.
print 2 + 2  # оно выведет 4
```

К сожалению, это определённое нарушение Дзена Python, и оно уже устранено в Python 3. Если вы увидели при попытке выполнения
вашей программы ошибку вида

    SyntaxError: Non-ASCII character '\xd0' in file a.py on line 1, but no encoding declared
    
это верный признак того, что вы забыли указать кодировку в начале программы.


### Управляющие структуры

Познакомившись с переменными, мы немного расширили возможности нашего калькулятора и можем даже записать 
вычисления в файл с программой, выполнить её и вывести результат.

Но главным отличием программы от счётов или простейшего калькулятора является возможность *управлять выполнением* программы.
Простой пример: мы хотим вывести абсолютную величину (модуль) числа, то есть неотрицательное значение, равное самому числу в случае,
 если оно больше либо равно нулю, или числу с противоположным знаком в ином случае (меньше нуля).
Получается, нам нужно выполнить вывод числа в зависимости от его значения, а именно от знака. 
Простым языком это описывалось бы как-то так:
   
    ЕСЛИ х МЕНЬШЕ НУЛЯ: выведем значение x с противоположным знаком 
    ИНАЧЕ: выведем значение x

В Python, это будет выглядеть почти так же, только на "английском".
 
:point_up: Напомним только, что для использования переменной в программе нам необходимо её вначале объявить.

```python
x = -1  # чтобы объявить переменную х, присвоим ей значение, для примера -1
if x < 0: print -x  # первое print-утверждение
else: print x  # второе print-утверждение
```

В выводе программы мы увидим число `1`. В данном случае выполнилось первое `print`-утверждение, выведя значение выражения `-x`. 
Второе же не было выполнено.
 
Если в утверждении присваивания `x` мы поставим `1` вместо `-1`, то мы также увидим `1`.
На этот раз выполнилось второе print-утверждение с выражением `x`.
       
Что есть что в этой записи?

#### Ключевые слова if, else. Условные утверждения

**if**, **else** &mdash; это ключевые слова в Python. Каждое из этих слов вводит соответствующие утверждения.

Во второй строке примера находится *if-утверждение*, которое содержит в себе первое `print`-утверждение. 
За ним следует *else-утверждение*, которое также содержит в себе  второе `print`-утверждение.

Как же так, ведь выше мы упомянули, что утверждения записываются по одному в строке? Да, это совершенно верно по отношению к простым
утверждениям. *Сложные утверждения* могут допускать и несколько утверждений в строке, 
а могут растягиваться на многие строки. Сложное утверждение можно отличить по наличию знака `:`.
  
Вид утверждения `if` такой:

    if УСЛОВИЕ: БЛОК КОДА 1
    
Утверждение `else` может идти только после `if`-утверждения и имеет вид

    else: БЛОК КОДА 2
    
В нашем примере блок кода 1 &mdash; это первое `print`-утверждение, блок кода 2 &mdash; второе. 

:bulb: Количество пробелов вокруг `:` не имеет значения, но в общепринятом стиле знак  `:` непосредственно (без пробела) 
следует за ключевым словом либо выражением в утверждении, а за ним
следует ровно один пробел.

Утверждения `if` и `else` в паре :clock2: образуют *условное утверждение*, являющееся также логической *управляющей структурой*.

:star: Управляющая структура &mdash; синтаксическая конструкция, позволяющая в зависимости от заданных условий изменять 
последовательность выполнения утверждений в программе.  

В случае условного утверждения, это значит, что 
если выполняется условие, указанное в `if`-утверждении, то будет выполнен блок кода, включённый в него, но
блок кода в `else`-утверждении будет пропущен. 
Если же это условие НЕ выполняется, то  первый блок кода не выполнится, 
а управление получит второй блок кода &mdash; в `else`-утверждении.


#### Условия: Операторы сравнения

Мы использовали в  `if`-утверждении оператор "меньше", это один из *операторов сравнения*. Всего их шесть:

* меньше: &lt;
* больше: &gt;
* меньше или равно: &lt;=
* больше или равно: &gt;=
* равно: ==
* не равно: !=

Операторы *бинарные*, то есть у них два операнда &mdash; левый и правый, ими могут быть, как обычно, любые выражения. 

:bulb: Как обычно, записывают эти операторы, отделяя операнды пробелами (по одному). 

#### Блоки кода

:star: Блок кода &mdash; это часть кода, которая должна быть выполнена в программе (или НЕ выполнена) в рамках управляющей структуры. 

:warning: Блок кода состоит из одного или нескольких утверждений и сам является частью соответствующего утверждения. Блоки кода 
могут быть вложенными. 
 
Для того, чтобы было понятно, где кончается одно утверждение и начинается другое, блоки кода специально выделяются.

:point_up: В ЯП<sup>[1](#yap)</sup> типа С, С++, Java и подобных обычно блоки кода находятся внутри фигурных скобок, в Pascal &mdash; между ключевыми словами begin/end.

В Python, вложенный блок кода выделяется отступами от начала строки до первого символа утверждения. 
Отступы можно формировать пробелами или табуляцией (клавиша tab), главное, чтобы
 
 * все утверждения, принадлежащие одному блоку кода, находились на одном уровне отступов, и 
 * величина отступа соответствовала уровню вложенности блоков.

:bulb: Уровень отступа в Python обычно состоит из одного или нескольких *единичных отступов*, в количестве, равном уровню вложенности блока.
Общепринятого соглашения по величине единичного отступа, увы, нет. Наиболее популярен его размер в 4 пробела. В PyCharm, 
а также в других средах разработки и большинстве продвинутых текстовых редакторов это можно настроить и устанавливать отступы клавишей tab.

---
:point_up: Небольшое отступление для читателей, знакомых с другими ЯП<sup>[1](#yap)</sup>:

> Python часто и чаще всего критикуют именно за выделение блоков кода отступами. В частности, если вдруг в редакторе нет поддержки табуляции
 или при передаче кода в skype и подобных программах, отступы могут теряться. 
Однако по сравнению с другими способами выделения блоков, отступы имеют следующие преимущества:

* визуально легко разделять блоки;
* нет необходимости в лишних видимых символах, в общем не имеющих смысла для восприятия программы, а зачастую ещё и имеющих другие 
  значения в других контекстах;
* при других способах выделения блоков всё равно хорошим стилем является соблюдение визуальных отступов, так что Python
  с одной стороны форсирует хороший стиль кода, с другой &mdash; использует хороший стиль в практических целях.

---


:bulb: Если блок кода в составе утверждений `if`/`else` состоит из одного утверждения, его вполне корректно записать и на той же строке,
что и ключевое слово &mdash; сразу после двоеточия, как сделано в приведённом примере. Однако принято записывать даже одиночные вложенные утверждения на отдельной строке,
выделяя её отступами, это делается для читаемости. После улучшения наш пример примет вид:

```python
x = -1  # чтобы объявить переменную х, присвоим ей значение, для примера -1
if x < 0: 
    print -x  # первое print-утверждение
else: 
    print x  # второе print-утверждение
```

Далее мы будем придерживаться этого стиля и в примерах, и в псевдокоде.

Для иллюстрации состава и уровней вложенности блоков кода модифицируем пример с нахождением абсолютной величины числа.
Предположим, нам хочется убедиться, что мы не просто вывели значение абсолютной величины переменной `x`, но и выполнился именно тот 
блок кода, который соответствовал условию. (Пример немного надуманный, но часто бывает удобно добавить `print` 
для такой проверки, в целях отладки.)

    ЕСЛИ х меньше нуля: 
        напечатаем значение x  (чтобы убедиться, что выполнился именно этот блок кода) 
        напечатаем значение -x
    ИНАЧЕ: 
        напечатаем значение x  (чтобы убедиться, что выполнился именно этот блок кода) 
        напечатаем значение x

Уже из текста (такой текст-аналог кода часто называют :star: *псевдокодом*) видно, что нам будет необходимо по два `print`-утверждения 
в каждом блоке кода (в `if`-утверждении и в `else`-утверждении). 

Реализуем это в коде (учтя необходимость объявить переменную перед использованием):

```python
x = -1
if x < 0:
    print x 
    print -x 
else:
    print x 
    print x 
```

Для случая с `x = -1` мы увидим выведенные значения `-1`, `1` . Для случая с `x = 1` мы увидим два раза единицу.

Ну и никто не мешает нам вместо `print`-утверждения использовать и вложенную управляющую структуру `if`-`else` &mdash; например, 
при обработке случая с `x = 0` мы решили не выводить `0`. Запишем в псевдокоде :

    ЕСЛИ х меньше нуля: 
        напечатаем значение x  (чтобы убедиться, что выполнился именно этот блок кода) 
        напечатаем значение -x
    ИНАЧЕ: 
        ЕСЛИ х равен нулю:
            не выводим значение
        ИНАЧЕ:
            напечатаем значение x  (чтобы убедиться, что выполнился именно этот блок кода) 
            напечатаем значение x

Как видно из псевдокода, у нас появляется вложенная логическая структура `if`-`else` во втором блоке кода (`else`-утверждении).
Но интересно и другое: не выводим значение &mdash; а что же делаем вместо этого?

#### Утверждение `pass`

Ответ на этот вопрос нам даёт *pass-утверждение*.

:star: `pass`-утверждение &mdash; это утверждение об отсутствии в нём выражения. 

Оно состоит из ровно одного ключевого слова `pass` и не содержит вычисляемого выражения. 

Запишем наш пример на Python:

```python
x = -1
if x < 0:
    print x 
    print -x 
else:
    if x == 0:  # используем описанный выше оператор сравнения по равенству
        pass
    else:
        print x 
        print x 
```

Для чего может быть полезно такое "пустое" утверждение? Например, для того, чтобы в будущем внести на его место что-то внятное.
Но часто его применяют и для улучшения читаемости кода. Поясним на следующем примере.

На самом деле, мы можем изменить наш второй `if`-`else` блок так, чтобы, наборот, 
 выводить `х` в случае если x не равен 0, так как это логически эквивалентно:
 
    ЕСЛИ х меньше нуля: 
        напечатаем значение x  (чтобы убедиться, что выполнился именно этот блок кода) 
        напечатаем значение -x
    ИНАЧЕ: 
        ЕСЛИ х НЕ РАВЕН нулю:
            напечатаем значение x  (чтобы убедиться, что выполнился именно этот блок кода) 
            напечатаем значение x
        ИНАЧЕ:
            не выводим значение

Пришло время сказать, что :exclamation: в управляющих структурах Python `else`-утверждение необязательно. И если у нас нет необходимости 
 выполнять действия в блоке ИНАЧЕ, то мы можем его просто опустить, ограничившись одним `if`-утверждением:


    ЕСЛИ х меньше нуля: 
        напечатаем значение x  (чтобы убедиться, что выполнился именно этот блок кода) 
        напечатаем значение -x
    ИНАЧЕ: 
        ЕСЛИ х НЕ РАВЕН нулю:
            напечатаем значение x  (чтобы убедиться, что выполнился именно этот блок кода) 
            напечатаем значение x

На Python это будет выглядеть так:

```python
x = -1
if x < 0:
    print x 
    print -x 
else:
    if x != 0:  # используем описанный выше оператор сравнения по неравенству
        print x 
        print x 
```

Но часто нам важно подчеркнуть, что в случае с `x = 0` мы намеренно не предпринимаем ничего, и в целях читаемости и наглядности
мы и используем вариант с `pass`.

#### Более сложные управляющие структуры

Помните принцип из Дзена Python "плоское лучше, чем вложенное"? Проиллюстрируем это на последнем примере, где 
условие `x != 0` непосредственно следует за ключевым словом `else` &mdash; "ИНАЧЕ": в русском языке мы бы записали это через запятую:

    ... иначе, если `x != 0` ...

Чтобы избежать излишней вложенности в управляющих структурах, для подобных случаев существует "плоская" форма `if`-`else`-`if` структуры,
 с ключевым словом `elif` &mdash; сокращённое `else if`.

```python
x = -1
if x < 0:
    print x 
    print -x 
elif x != 0:
    print x 
    print x 
```

Количество блоков `elif` в структуре не ограничено.  В структуре может также содержаться и блок `else`, который
 является так же, как и в простом `if`-`else` утверждении, необязательным, 
 но при наличии, он должен быть последним блоком в структуре:

```python
x = -1
if x < 0:
    print x 
    print -x 
elif x != 0:
    print x 
    print x 
else:
    pass
```

:exclamation: Из всей структуры `if`-`elif`-`else` может выполниться только *один* блок кода,
который *первым* соответствует указанному в нём условию (для `if` и `elif`), 
даже если после этого есть другие подходящие блоки,  либо блок `else` (или просто ничего, если блок `else` отсутствует), 
в случае если ни одно условие не верно. 

Например:


```python
x = 3
if x > 1:
    print 1  # выведет 1 
elif x > 2:
    print 2  # не выполнится
else:
    print 3  # не выполнится
```
Если в этот пример подставить ``

---
:point_up: Небольшое отступление для читателей, знакомых с другими ЯП<sup>[1](#yap)</sup>:

> Во многих ЯП используются также условные структуры `case` или `switch`. В Python такой структуры нет, так как структура
`if`-`elif`-`else` является практически полноценной заменой, однако может возникнуть резонный вопрос: ведь выражения в утверждениях `if`-`elif` 
вычисляются каждый раз заново, в то время как в `switch` только один раз. Но это не совсем так: операции сравнения в блоках `case` 
оператора `switch` выполняются также каждый раз, а более сложное выражение гораздо удобнее (помните принцип "читаемость имеет значение"?)
 вычислить заранее единожды, присвоить его
значение переменной и сравнивать эту переменную сколько понадобится. Впрочем, в Python есть ещё более продвинутые техники, которые позволяют
выполнять однократное сравнение, но об этом позже.

---

## Резюме

В этой лекции мы узнали о главном отличии программы от калькулятора &mdash; наличии управляющих структур, 
написали первую программу в файле и получили из неё вывод результата. Мы также повстречались с новыми операторами &mdash; сравнения, 
ключевыми словами `print` и `pass`, познакомились с псевдокодом.


## Задания

*Небольшая рекомендация:* 
сохраняйте все написанные вами программы в папки с названиями по номеру лекции, в файлы с 
названиями, содержащими номер задания, например `lect_2/program1.py`. Они вам ещё пригодятся.  

1. Поменять знак в значении переменной, не меняя её имени (да, такое возможно!). Если в утверждении присваивания 
присвоить уже объявленной переменной значение выражения, содержащего ту же переменную, то после вычисления этого выражения 
она получит новое значение. 
Сделать это двумя способами &mdash; с помощью унарного оператора *минус* и арифметическим способом: умножив на `-1`.
Результат вывести в утверждении `print`.
2. Написать программу (создать файл программы, не забыв указать в ней обязательный комментарий о кодировке), 
   которая выводит результат вычисления формулы
   
        (x + 2) / (x - 2)
    
   при этом учесть следующее:
    * значение `x` может быть как вещественным, так и целым, в последнем случае результат деления может не совпадать
      с ожидаемым. Чтобы этого избежать, рекомендуется использовать литерал `2.0` вместо `2`;
    * для значения `x`, при котором может возникнуть ошибка *ZeroDivisionError*, не выводить ничего,   
      указав в комментариях, почему требуется именно такое условие.
      
   *Проверка:* результата выполнения программы:
        
    * при `x = 1` программа выведет число `-3.0`; 
    * при `x = 2` программа не выведет ничего;
    * при `x = 3` программа выведет число `5.0`;

    и т.п.
   
3. Написать программу, аналогичную предыдущему заданию, но с двумя переменными: `x` и `y`, и формулой

        (x + y) / (x - y)

    Обратите внимание, что, как и в предыдущем примере, `x` и `y` могут быть целыми, но мы уже не можем использовать
    вещественную запись для *переменных*, поэтому одной из часто используемых техник является добавление к переменной
    вещественного числа `0`, например:
    
        x = x + 0.0 
   
   или умножение на вещественное число `1`:

        y = y * 1.0 
   
   В этом случае, как мы помним из первой лекции, значение `x` гарантированно будет вещественным числом. 

4. Написать программу нахождения максимума: в её начале задаются 5 переменных `a1`, `a2`, `a3`, `a4`, `a5` 
   (можно назвать их *константами*),
   далее задаётся переменная `maximum`. Написать условную конструкцию, которая по очереди проходит по заданным 
   константам и обновляет `maximum` каждый раз, когда константа больше текущего значения максимума.
   Значения для констант можно выдумать любые и поэкспериментировать с разными комбинациями.
5. Написать программу-счётчик: в её начале задаются 5 констант `a1`, `a2`, `a3`, `a4`, `a5`,
   далее задаётся переменная-счётчик `counter`. Написать условную конструкцию, которая проходит по заданным 
   константам и увеличивает счётчик на единицу каждый раз, когда абсолютная величина константы больше 5 (10, 100).

***

### Примечания

<a name="yap">1</a>: ЯП &mdash; сокращение для "Языки программирования"

<a name="nb_1">NB 1</a>: Альтернативы, конечно же, есть, но они более специфичны для конкретных случаев и менее очевидны. 
     Здесь работает принцип Дзена Python: Должен быть один, и желательно, только один очевидный способ сделать это.

<a name="nb_2">NB 2</a>: В Python допускается запись и больше чем одного утверждения в строке, разделяя их символом `;`. 
    Это не практикуется в программах в целях читаемости. Однако в некоторых случаях такая функциональнось бывает удобной и 
    встречается. Один из  принципов Дзена Python как раз гласит "практичность важнее безупречности")
     
