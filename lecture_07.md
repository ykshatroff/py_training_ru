Лекция 7. Исключения: обработка и вызов. Иерархия типов 
=========


### Значки, используемые в тексте

* :clock2: &mdash; отмечает, что высказывание не совсем верно, но будет уточнено позднее.
* :star: &mdash; выделяет определение нового понятия.
* :exclamation: &mdash; привлекает внимание к высказыванию.
* :point_up: &mdash; указывает на небольшое отступление от темы или уточнение.
* :bulb: &mdash; индикатор традиций и договорённостей. 
* :warning: &mdash; требуется осторожность: возможно, сложное высказывание.  

### Повторение терминов из шестой лекции

* *Объект* &mdash; любая сущность данных, которая может являться результатом выражения.
* *Тип объекта* &mdash; объект, возвращаемый функцией `type(x)`.
* *Идентичность объекта* &mdash; число, возвращаемое функцией `id(x)` и являющееся уникальным для каждого объекта.
* *Оператор `is`* &mdash; оператор, сравнивающий идентичность двух объектов.
* *Атрибут объекта* &mdash; другой объект, связанный с первым специальным отношением членства 
   и доступный через оператор `.`.
* *Метод объекта* &mdash; атрибут, являющийся функцией, которой неявно передаётся объект-хозяин.


## Исключения

Мы уже сталкивались с разными видами исключений, встроенных в Python: `TypeError` при операциях над несовместимыми типами и несовпадающих
аргументах, `ValueError` при неудачной попытке  сконвертировать строку в число, `AssertionError` при невыполняющемся
 предположении в `assert` ...
 
Исключение в Python &mdash; это тоже объект, который содержит в себе информацию об ошибке, такую как её тип, текст сообщения об ошибке,
место её возникновения и некоторый контекст.

Обработка ошибок, таким образом, сводится к *перехвату* ошибки, выполнению действий 
по возврату программы в нормальное состояние (или по корректному завершению программы) 
и, при необходимости, 
чтению этой информации из объекта исключения.

## Утверждение `try: except`

Однако не любая ошибка должна быть перехвачена: до сих пор наши программы просто "падали", если возникали ошибки.
Для перехвата ошибки необходимо специально обозначить тот код, где возможна ошибка, которую необходимо отслеживать.
  
Для этой цели существует сложное утверждение `try: except`, которое состоит из двух обязательных частей:

    try:  БЛОК_КОДА
    except: БЛОК_КОДА
    
В блоке `try` выполняются потенциально ошибкоопасные утверждения, в блоке `except` идёт обработка возможных ошибок,
вызванных первым блоком. Если некое утверждение в блоке `try` вызвало ошибку, то оно немеденно прерывается, следующие
за ним в этом блоке утверждения не выполняются, а управление переходит в блок `except`.

Пример:

```python
# coding: utf-8
try:
    print 1  # выполнится
    print 1 + "1"  # вызывает TypeError, НЕ выполнится
    print 2  # НЕ выполнится
except:
    print "Ошибка"  # выведет "Ошибка"
```
В результате этого кода мы увидим в консоли:

    1
    Ошибка

Если в блоке `try` ошибки не произошло, блок `except` будет проигнорирован полностью.

```python
# coding: utf-8
try:
    print 1  # выполнится
    print 1 + 1  # ошибки нет, выполнится и выведет 2
    print 2  # выполнится
except:
    print "Ошибка"  # не выполнится
```
В этом случае мы увидим:

    1
    2
    2

Если утверждение, в котором произошла ошибка, более сложное, то возможна ситуация, когда оно прервано в середине,
то есть часть его выполнилась, а оставшаяся часть &mdash; нет. В этом случае нужно мысленно разбить утверждение на части,
 чтобы понять, в какой момент его выполнение прекратится и каков будет результат. Рассмотрим такой пример:
 
```python
# coding: utf-8
def f():
    print "В функции f()"


try:
    print "Тест"  # выполнится
    x = 1 + f()  # вызовет TypeError, так как функция f() возвращает значение None, которое нельзя сложить с числом 
    print x  # НЕ выполнится
except:
    print "Ошибка"  # не выполнится

print x  # ошибка NameError: переменная х не определена
```

Для того, чтобы определить результат сложения `1 + f()`, интерпретатору сперва необходимо *выполнить* функцию `f()`.
Исключение возникнет уже тогда, когда мы получим результат функции, но ещё до того момента, как будет выполнено присваивание
переменной `x` значения выражения с этой функцией.

Поэтому на экране мы увидим:

    Тест
    В функции f()
    Traceback (most recent call last):
    ...
    NameError: name 'x' is not defined

То есть, всё, что произошло *до* исключения, остаётся "в силе" (а именно, `print` из функции). То, что могло произойти
 после этого момента, не будь ошибки &mdash; не реализуется: переменная `x` не создастся, так как её значение нельзя вывести.
 
Всё, что является результатом реально выполненных до ошибки 
действий в блоке `try`, будет доступно и в выполняемом блоке `except`:

```python
# coding: utf-8
try:
    x = 1
    x += "1"  # TypeError
except:
    print "Ошибка"
    assert x == 1
```
То есть, присвоенное переменной `x` до ошибки значение будет доступно и в выполняемом блоке `except`. 


## Информация об исключении

### Типы исключений

Код потенциально может вызывать разные виды ошибок, и от их типа может зависеть реакция на них. 
Скажем, при обработке ввода с клавиатуры возникающая ошибка в значении должна приводить к повторному запросу ввода,
а ошибка в количестве аргументов функции говорит о том, что программа некорректна в принципе.

Блок `except:` выполняется при любой ошибке, и это в Python считается плохим стилем: нужно перехватывать только
те ошибки, которые мы в состоянии обработать и продолжить программу.
 
Для этого в утверждении `except` можно указать тот тип ошибки, который оно будет обрабатывать: 

    try:  БЛОК_КОДА
    except ТИП_ОШИБКИ: БЛОК_КОДА
    
В таком варианте обрабатываться будет только указанный тип ошибки, ошибки всех остальных типов будут, как и прежде, 
приводить к краху программы.

Пример:

```python
# coding: utf-8
try:
    print 1 + "1"  # вызывает TypeError
except TypeError:
    print "Ошибка"  # выведет "Ошибка"

try:
    print 1 + int("x")  # вызывает ValueError &mdash; программа завершится по ошибке
except TypeError:
    print "Ошибка"  # не выполнится
```

Некоторые известные нам типы исключений встроены в Python:

* `SyntaxError` &mdash; ошибка синтаксиса, её обычно не перехватывают, потому что Python сделает это до вас :) файл,
  содержащий синтаксические ошибки, не может быть обработан. Хотя теоретическая возможность перехватить это исключение есть :clock2:;
* `IndentationError` &mdash; тоже ошибка синтаксиса, возникающая при неверном количестве отступов;  
* `NameError` &mdash; возникает при обращении к необъявленной переменной или функции;
* `ValueError` &mdash; возникает при попытке сконвертировать в число нечисловую строку, и т.п;
* `TypeError` &mdash; возникает при некорректных операндах операторов, несовпадающем количестве аргументов функции;
* `ZeroDivisionError` &mdash; при делении на 0;
* `AssertionError` &mdash; при невыполнении предположения в утверждении `assert`;
* `UnicodeDecodeError` &mdash; при некорректной кодировке строк или невозможности привести простоую строку к строке unicode;
* `AttributeError` &mdash; при попытке доступа к несуществующему атрибуту объекта;
* `IndexError` &mdash; при попытке доступа к несуществующему элементу контейнера.

Помимо них, есть ещё множество других встроенных типов исключений, а также :clock2: возможность создавать свои типы, которую
мы откроем позже.

## Обработка разных исключений от одного блока `try`

Что если один блок кода в `try` потенциально может генерировать несколько типов ошибок? Мы конечно могли бы
обернуть всё утверждение `try: except XXX` в ещё одно такое же утверждение с другим типом, но к счастью есть более простой способ:
блоков `except` может быть несколько. 
Более того, последним можно указать блок `except:` *без типа* исключения,
таким образом все не перехваченные в типизированных `except` типы исключений будут перехвачены в нём:  

    try:  БЛОК_КОДА
    except ТИП_ОШИБКИ_1: БЛОК_КОДА
    except ТИП_ОШИБКИ_2: БЛОК_КОДА
    ...
    except: БЛОК_КОДА

:exclamation: При любом количестве блоков `except` в утверждении `try: except` выполняется всегда максимум 1 блок: 
либо `try`, если ошибки не было, либо первый типизированный блок `except`, тип исключения в котором совпадает с типом вызванного
исключения, либо при наличии &mdash; нетипизированный `except`.

:exclamation: Нетипизированный блок `except` необязателен, но при его наличии он должен быть последним из `except`-блоков.
 
```python
# coding: utf-8
try:
    x = input("Введите x")
    y = input("Введите y")
    assert int(x + y) > 0 # может вызвать TypeError, ValueError или AssertionError
except TypeError:
    print "Ошибка: х и y нельзя сложить"
except ValueError:
    print "Ошибка: х и y не могут быть преобразованы в число"
except AssertionError:
    print "Ошибка: х + y не больше нуля"
except:
    print "Непредусмотренная ошибка"
```

Часто бывает интересно и даже необходимо узнать, что за ошибка произошла. Для этого *типизированное* утверждение `except` можно
записать с указанием временной переменной, в которую сохранить объект исключения. Имя переменной указывается после
 ключевого слова `as`:

    try:  БЛОК_КОДА
    except ТИП_ОШИБКИ_1 as e: БЛОК_КОДА
    except ТИП_ОШИБКИ_2 as e: БЛОК_КОДА

Имя переменной (обычно `e`, `ex` или другое) будет доступно внутри того блока `except`, в котором оно указано.
Можно (и удобно) указывать для разных блоков одно и то же имя, так как всё равно выполнится только один блок.

:point_up: В Python 2 переменная, содержащая ошибку (если ошибка произошла), будет доступна после утверждения `try: except`.
Однако в Python 3, она доступна только в том блоке `except`, в начале которого объявлена.

У переменной, хранящей объект исключения, будут доступны некоторые атрибуты плюс возможность сконвертировать
её в строку и вывести:

```python
# coding: utf-8
try:
    x = input("Введите x")
    y = input("Введите y")
    assert int(x + y) > 0 # может вызвать TypeError, ValueError или AssertionError
except TypeError as e:
    assert type(e) == TypeError
    print "Ошибка х и y нельзя сложить"
    print e  # выведет "unsupported operand type(s) for +: ..."
    print e.message  # выведет то же
    assert str(e) == e.message
except ValueError as e:
    assert type(e) == ValueError
    print "Ошибка: х и y не могут быть преобразованы в число"
except AssertionError as e:
    assert type(e) == AssertionError
    print "Ошибка: х + y не больше нуля"
except:
    print "Непредусмотренная ошибка"
```

### Общий блок `except` для нескольких типов исключений

Хорошо, но возникает вопрос: что делать, если хочется для разных типов исключений выполнить одну и ту же обработку?
Скопировать блок кода и вставить его в несколько блоков `except` с разными типами? Не нужно! В Python можно перечислить
все эти типы исключений в одном блоке `except` в виде кортежа:

```python
# coding: utf-8
try:
    x = input("Введите x")
    assert int(x) > 0 # может вызвать TypeError, ValueError или AssertionError
except (TypeError, ValueError, AssertionError) as e:
    print e
```

Часть `as e` необязательна, если объект исключения нам не нужен.

:exclamation: Хотя кортежи допускается объявлять без круглых скобок, в утверждении `except` в Python 2.7 *обязательно*
 использовать скобки вокруг списка типов исключений. Это связано с особенностью синтаксиса более старых версий Python,
 про которые можно не знать. В Python 3 скобки уже не обязательны. 

## Блок `else`

Предположим, нужно не только обработать ошибку, но и в зависимости от её наличия выполнять разные действия.

Для этого можно поступить двумя способами:
* ввести булеву переменную-флаг:
     
        error = False
        try:
            ...
        except:
            error = True
            
        if error:
            do_on_error()
        else:
            do_on_success()
            
* попробовать выполнить всё, что нужно, в блоках `try` и `except`  

        try:
            ...
            do_on_success()
        except:
            do_on_error()

Но и первый, и второй способы имеют недостатки: в первом вводится лишняя переменная и лишнее условие, 
плюс при большем, чем 1, количестве блоков `except`, нужно в
 каждом блоке продублировать присваивание `error = True`. Во втором случае, код `do_on_success()` может также
 вызвать ошибку, которая случайно попадёт в обработку в блок `except`, да и опять же возможно дублирование 
 кода `do_on_error()` при нескольких блоках обработки.
 
В Python в утверждении `try: except` предусмотрен для этой цели специальный блок `else`:
 
        try:
            ...
        except:
            do_on_error()
        else:
            do_on_success()

Блок `else` можно использовать в любом виде утверждения `try: except` *после всех* блоков `except`, и выполнится он
только в случае, если блок `try` не вызвал никакой ошибки.

Давайте добавим блок `else` в пример выше:

```python
# coding: utf-8
def f():
    print "В функции f()"


try:
    print "Тест"  # выполнится
    x = 1 + f()  # вызовет TypeError, так как функция f() возвращает значение None, которое нельзя сложить с числом 
    print x  # НЕ выполнится
except:
    print "Ошибка"  # не выполнится
else:
    print x  # НЕ выполнится
```
На экран выведется:
  
    Тест
    В функции f()

Но программа не "упадёт", потому что блок `else`, в котором использован необъявленный (в случае ошибки) 
"икс", не выполнится.

Попробуем поменять функцию, чтобы она возвращала корректное значение-число:
```python
# coding: utf-8
def f():
    print "В функции f()"
    return 10


try:
    print "Тест"  # выполнится
    x = 1 + f()  #  
    print x  # 11
except:
    print "Ошибка"  # не выполнится
else:
    print x  # 11
```
Получим на экране:

    Тест
    В функции f()
    11
    11
    
То есть, переменная `x` успешно создана и доступна в блоке `else`.

## Общий тип исключений `Exception. Тип `object`

Немного забегая вперёд, скажем, что типы исключений, как и все типы данных в Python, имеют так называемую иерархию наследования.

Существует один встроенный тип исключений &mdash; `Exception`, который можно назвать *корневым*:
 все объекты исключений принадлежат как к своему типу, так и к типу `Exception`.
 
Это можно объяснить так: любое исключение &mdash; это ошибка. 
При этом любое исключение &mdash; это также и *объект*. В Python существует специальный встроенный тип `object`, который является
корневым для всех-всех типов языка. 

Аналогия из мира геометрии: любой квадрат является прямоугольником, а любой прямоугольник - геометрической фигурой. 

Важное следствие из этого конкретно для обработки исключений состоит в том, что мы можем обрабатывать исключения любых
 типов и при этом сохранять их в переменную в одном блоке `except`:
 
```python
# coding: utf-8
try:
    x = input("Введите x")
    y = input("Введите y")
    assert int(x + y) > 0 # может вызвать TypeError, ValueError или AssertionError
except Exception as e:
    print e
```

Какого бы типа ни было исключение, оно будет перехвачено и выведено.

## Вызов исключений своими руками. Утверждение `raise`

Рассмотрим такую ситуацию: мы пишем игру, например, шахматы, и пользователь вводит с клавиатуры номер клетки, 
куда будет ходить. То есть у нас есть ограничения не только на тип ввода, но на диапазон вводимых чисел: от 1 до 8.
При этом любой ошибочный ввод можно обрабатывать одинаково: выводить сообщение и запрашивать повторный ввод.
 
Такую схему можно реализовать с помощью условных конструкций, но добиться обработки ошибки в одном месте (чтобы избежать
копирования кода) будет сложно и некрасиво. А так как введённое число, не попадающее в диапазон, это в общем такая же
ошибка, как и ввод не-числа, логично, что её было бы неплохо как-то вызывать вручную. 

Это делается с помощью утверждения `raise`, которое выглядит как

    raise ТИП_ОШИБКИ
    
или
    
    raise ТИП_ОШИБКИ(АРГУМЕНТЫ)
    
Фактически справа от ключевого слова `raise` идёт выражение, вычисляющееся в тип исключения, либо в объект исключения (который
производится из типа с помощью оператора "круглые скобки", аналогично вызову функции).

В качестве типа исключения можно использовать любые встроенные типы, перечисленные выше, от общего `Exception` до 
`ZeroDivisionError`, но желательно, чтобы тип исключения соответствовал реальной ошибке. Поэтому наиболее часто
вызываются вручную `ValueError` либо `TypeError`, и в нашей ситуации с шахматами они вполне годятся:

```python
# coding: utf-8
input_correct = False
while not input_correct:
    try:
        x = int(input(u"Введите Х от 1 до 8"))  # потенциальный источник TypeError или ValueError
        y = int(input(u"Введите Y от 1 до 8"))  # потенциальный источник TypeError или ValueError
        if x < 1 or x > 8 or y < 1 or y > 8:  
            raise ValueError(u"Значения X и Y должны быть от 1 до 8")  # вызываем ValueError: передаём сообщение об ошибке
    except (TypeError, ValueError) as e:
        print u"Некорректно введены значения: %s. Повторите ввод" % e  # выводим подробности ошибки
    else:
        input_correct = True  # выходим из цикла ввода
    
```
Из примера видно, что в качестве аргумента *конструктору типа* `ValueError` можно передать текст сообщения, который
потом будет выведен при преобразовании исключения в строку.

## Резюме

Сегодня мы узнали почти всё про обработку ошибок в Python. Мы перечислили известные нам типу исключений и установили,
 что они все также принадлежат к общему "корневому" типу `Exception` (наследуются от него). Мы научились
 использовать конструкции `try: except: else` для перехвата исключений и утверждение `raise` для их вызова вручную.
   
## Задания

1. Написать программу, которая запрашивает ввод строки с арифметическим выражением вида `"234 + 465"` 
   и вычисляет его результат.
   Для ввода строки без кавычек можно использовать не `input()`, a `raw_input()` &mdash; функцию, которая рассматривает
    любое введённое значение как текст (строку), не вычисляя его сразу, таким образом вводить кавычки будет не нужно.

   В выражении допускаются только числа (целые или дробные, на ваше усмотрение).
   Операторы: `+`, `-`, `*`, `/`, `%`. 

*Подсказки:*
* Для разбора строки удобно использовать метод `str.startswith()`, параметром которого является также строка, а
  результатом &mdash; булево значение, истинное, если строка начинается со строки-параметра.

    ```python
    assert "apple".startswith("app")
    ```
  
  

* Чтобы убрать лишние пробелы (в XML пробелы между тегами никак не учитываются), можно использовать метод
    `str.strip()` без параметров, возвращающий новую строку, у которой обрезаны 
    все пробельные символы сначала и с конца.
    Пример:
    
    ```python
    assert "  asd ".strip() == "asd"
    ```  
    Символы "перевода строки" также относятся к пробельным.  
   

2. Написать программу, которая запрашивает ввод значений для установки одного поля
   игры крестики-нолики: сначала Х, потом У, затем &mdash; 
   какой значок поставить. Х и У должны быть числами от 1 до 3, значок &mdash; ноль или буква О для нолика, Х для крестика.
   
   Запрашивать ввод значений в цикле до тех пор, пока не будет введено корректное значение, и вывести его в виде
   "X,Y: 0". 

3. Дана строка с данными в формате XML:

```python
xml = """
<data>
    <row>
        <col>0</col>
        <col>1</col>
        <col>0</col>
    </row>
    <row>
        <col>0</col>
        <col>0</col>
        <col>1</col>
    </row>
    <row>
        <col>0</col>
        <col>1</col>
        <col>1</col>
    </row>
</data>
"""
```

В этой строке содержится информация об игровом поле для крестиков-ноликов: тег `<row>` содержит строку, состоящую
 из столбцов-тегов `<col>`, в которых записано значение клетки: 0 - нолик, 1 - крестик. 

Необходимо вычленить эти значения из строки и составить вложенный список (список из "рядов"-списков, в которых
содержатся "столбцы"-значения). При этом:
* нужно убедиться, что кол-во тегов `<col>` в теге `<row>` и тегов `<row>` в теге `<data>` равно 3, иначе --
    вызывать исключение;
* каждое значение из XML-строки необходимо проверять на допустимость: допускаются только числа 0 и 1.
  
В информацию об ошибке желательно добавлять порядковый номер ряда (row) и столбца (col).

*Подсказки:*
* Можно идти двумя путями: 
    * ожидать ровно 3 повторений тегов, используя для этого цикл по диапазону (встроенная функция `range(N)`,
    которая возвращает список из N чисел, начиная с 0 до N-1):
     
        ```python
        for i in range(3):
            next_tag()
        ```
    * второй вариант: сначала найти все теги этого типа (идущие подряд), потом подсчитать их количество.
    



4. Необходимо получить данные с клавиатуры и записать данные в аналогичную строку в формате XML:
    ожидаем ввод 9 значений 0 или 1, записываем их в строку под соответствующими тегами &mdash; первые 3 в первый "ряд",
    
    

