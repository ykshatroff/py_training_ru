Лекция 7. Исключения: обработка и вызов 
=========


### Значки, используемые в тексте

* :clock2: &mdash; отмечает, что высказывание не совсем верно, но будет уточнено позднее.
* :star: &mdash; выделяет определение нового понятия.
* :exclamation: &mdash; привлекает внимание к высказыванию.
* :point_up: &mdash; указывает на небольшое отступление от темы или уточнение.
* :bulb: &mdash; индикатор традиций и договорённостей. 
* :warning: &mdash; требуется осторожность: возможно, сложное высказывание.  

### Повторение терминов из шестой лекции

* *Объект* &mdash; любая сущность данных, которая может являться результатом выражения.
* *Тип объекта* &mdash; объект, возвращаемый функцией `type(x)`.
* *Идентичность объекта* &mdash; число, возвращаемое функцией `id(x)` и являющееся уникальным для каждого объекта.
* *Оператор `is`* &mdash; оператор, сравнивающий идентичность двух объектов.
* *Атрибут объекта* &mdash; другой объект, связанный с первым специальным отношением членства 
   и доступный через оператор `.`.
* *Метод объекта* &mdash; атрибут, являющийся функцией, которой неявно передаётся объект-хозяин.


## Исключения

Мы уже сталкивались с разными видами исключений: `TypeError` при операциях над несовместимыми типами и несовпадающих
аргументах, `ValueError` при неудачной попытке  сконвертировать строку в число, `AssertionError` при невыполняющемся
 предположении в `assert` ...
 
Исключение в Python -- это тоже объект, который содержит в себе информацию об ошибке, такую как её тип, текст сообщения об ошибке,
место её возникновения и некоторый контекст.

Обработка ошибок, таким образом, сводится к *перехвату* ошибки, выполнению действий 
по возврату программы в нормальное состояние (или по корректному завершению программы) 
и, при необходимости, 
чтению этой информации из объекта исключения.

## Утверждение `try: except`

Однако не любая ошибка должна быть перехвачена: до сих пор наши программы просто "падали", если возникали ошибки.
Для перехвата ошибки необходимо специально обозначить тот код, где возможна ошибка, которую необходимо отслеживать.
  
Для этой цели существует сложное утверждение `try: except`, которое состоит из двух обязательных частей:

    try:  БЛОК_КОДА
    except: БЛОК_КОДА
    
В блоке `try` выполняются потенциально ошибкоопасные утверждения, в блоке `except` идёт обработка возможных ошибок,
вызванных первым блоком. Если некое утверждение в блоке `try` вызвало ошибку, то оно немеденно прерывается, следующие
за ним в этом блоке утверждения не выполняются, а управление переходит в блок `except`.

Если в блоке `try` ошибки не произошло, блок `except` будет проигнорирован полностью.

Пример:

```python
# coding: utf-8
try:
    print 1 + "1"  # вызывает TypeError, не выполнится
except:
    print "Ошибка"  # выведет "Ошибка"
    
try:
    print 1 + 1  # ошибки нет, выведет 2
except:
    print "Ошибка"  # не выполнится
```

## Информация об исключении

### Типы исключений

Код потенциально может вызывать разные виды ошибок, и от их типа может зависеть реакция на них. 
Скажем, при обработке ввода с клавиатуры возникающая ошибка в значении должна приводить к повторному запросу ввода,
а ошибка в количестве аргументов функции говорит о том, что программа некорректна в принципе.

Блок `except:` выполняется при любой ошибке, и это в Python считается плохим стилем: нужно перехватывать только
те ошибки, которые мы в состоянии обработать и продолжить программу.
 
Для этого в утверждении `except` можно указать тот тип ошибки, который оно будет обрабатывать: 

    try:  БЛОК_КОДА
    except ТИП_ОШИБКИ: БЛОК_КОДА
    
В таком варианте обрабатываться будет только указанный тип ошибки, ошибки всех остальных типов будут, как и прежде, 
приводить к краху программы.

Пример:

```python
# coding: utf-8
try:
    print 1 + "1"  # вызывает TypeError
except TypeError:
    print "Ошибка"  # выведет "Ошибка"

try:
    print 1 + int("x")  # вызывает ValueError -- программа завершится по ошибке
except TypeError:
    print "Ошибка"  # не выполнится
```

Некоторые известные нам типы исключений встроены в Python:

* `SyntaxError` -- ошибка синтаксиса, её обычно не перехватывают, потому что Python сделает это до вас :)  
* `IndentationError` -- тоже ошибка синтаксиса, возникающая при неверном количестве отступов,  
* `ValueError` -- возникает при попытке сконвертировать в число нечисловую строку, и т.п
* `TypeError` -- возникает при некорректных операндах операторов, несовпадающем количестве аргументов функции,
* `ZeroDivisionError` -- при делении на 0,
* `AssertionError` -- при невыполнении предположения в утверждении `assert`,
* `UnicodeDecodeError` -- при некорректной кодировке строк или невозможности привести простоую строку к строке unicode
* `AttributeError` -- при попытке доступа к несуществующему атрибуту объекта,
* `IndexError` -- при попытке доступа к несуществующему элементу контейнера.

Помимо них, есть ещё множество других встроенных типов исключений, а также :clock2: возможность создавать свои типы, которую
мы откроем позже.

Что если один блок кода в `try` потенциально может генерировать несколько типов ошибок? Мы конечно могли бы
обернуть всё утверждение `try: except XXX` в ещё одно такое же утверждение с другим типом, но к счастью есть более простой способ:
блоков `except` может быть несколько. 
Более того, последним можно указать блок `except:` *без типа* исключения,
таким образом все не перехваченные в типизированных `except` типы исключений будут перехвачены в нём:  

    try:  БЛОК_КОДА
    except ТИП_ОШИБКИ_1: БЛОК_КОДА
    except ТИП_ОШИБКИ_2: БЛОК_КОДА
    ...
    except: БЛОК_КОДА

:exclamation: При любом количестве блоков `except` в утверждении `try: except` выполняется всегда максимум 1 блок: 
либо `try`, если ошибки не было, либо первый типизированный блок `except`, тип исключения в котором совпадает с типом вызванного
исключения, либо при наличии -- нетипизированный `except`.

:exclamation: Нетипизированный блок `except` необязателен, но при его наличии он должен быть последним из `except`-блоков.
 
```python
# coding: utf-8
try:
    x = input("Введите x")
    y = input("Введите y")
    assert int(x + y) > 0 # может вызвать TypeError, ValueError или AssertionError
except TypeError:
    print "Ошибка: х и y нельзя сложить"
except ValueError:
    print "Ошибка: х и y не могут быть преобразованы в число"
except AssertionError:
    print "Ошибка: х + y не больше нуля"
except:
    print "Непредусмотренная ошибка"
```

Часто бывает интересно и даже необходимо узнать, что за ошибка произошла. Для этого *типизированное* утверждение `except` можно
записать с указанием временной переменной, в которую сохранить объект исключения. Имя переменной указывается после
 ключевого слова `as`:

    try:  БЛОК_КОДА
    except ТИП_ОШИБКИ_1 as e: БЛОК_КОДА
    except ТИП_ОШИБКИ_2 as e: БЛОК_КОДА

Имя переменной (обычно `e`, `ex` или другое) будет доступно внутри того блока `except`, в котором оно указано.
Можно указывать для разных блоков одно и то же имя, так как всё равно только один блок выполнится.

У переменной, хранящей объект исключения, будут доступны некоторые атрибуты плюс возможность сконвертировать
её в строку и вывести:

```python
# coding: utf-8
try:
    x = input("Введите x")
    y = input("Введите y")
    assert int(x + y) > 0 # может вызвать TypeError, ValueError или AssertionError
except TypeError as e:
    assert type(e) == TypeError
    print "Ошибка х и y нельзя сложить"
    print e  # выведет "unsupported operand type(s) for +: ..."
    print e.message  # выведет то же
except ValueError as e:
    assert type(e) == ValueError
    print "Ошибка: х и y не могут быть преобразованы в число"
except AssertionError as e:
    assert type(e) == AssertionError
    print "Ошибка: х + y не больше нуля"
except:
    print "Непредусмотренная ошибка"
```
