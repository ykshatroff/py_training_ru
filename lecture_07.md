Лекция 7. Исключения: обработка и вызов. Иерархия типов 
=========


### Значки, используемые в тексте

* :clock2: &mdash; отмечает, что высказывание не совсем верно, но будет уточнено позднее.
* :star: &mdash; выделяет определение нового понятия.
* :exclamation: &mdash; привлекает внимание к высказыванию.
* :point_up: &mdash; указывает на небольшое отступление от темы или уточнение.
* :bulb: &mdash; индикатор традиций и договорённостей. 
* :warning: &mdash; требуется осторожность: возможно, сложное высказывание.  

### Повторение терминов из шестой лекции

* *Объект* &mdash; любая сущность данных, которая может являться результатом выражения.
* *Тип объекта* &mdash; объект, возвращаемый функцией `type(x)`.
* *Идентичность объекта* &mdash; число, возвращаемое функцией `id(x)` и являющееся уникальным для каждого объекта.
* *Оператор `is`* &mdash; оператор, сравнивающий идентичность двух объектов.
* *Атрибут объекта* &mdash; другой объект, связанный с первым специальным отношением членства 
   и доступный через оператор `.`.
* *Метод объекта* &mdash; атрибут, являющийся функцией, которой неявно передаётся объект-хозяин.


## Исключения

Мы уже сталкивались с разными видами исключений, встроенных в Python: `TypeError` при операциях над несовместимыми типами и несовпадающих
аргументах, `ValueError` при неудачной попытке  сконвертировать строку в число, `AssertionError` при невыполняющемся
 предположении в `assert` ...
 
Исключение в Python -- это тоже объект, который содержит в себе информацию об ошибке, такую как её тип, текст сообщения об ошибке,
место её возникновения и некоторый контекст.

Обработка ошибок, таким образом, сводится к *перехвату* ошибки, выполнению действий 
по возврату программы в нормальное состояние (или по корректному завершению программы) 
и, при необходимости, 
чтению этой информации из объекта исключения.

## Утверждение `try: except`

Однако не любая ошибка должна быть перехвачена: до сих пор наши программы просто "падали", если возникали ошибки.
Для перехвата ошибки необходимо специально обозначить тот код, где возможна ошибка, которую необходимо отслеживать.
  
Для этой цели существует сложное утверждение `try: except`, которое состоит из двух обязательных частей:

    try:  БЛОК_КОДА
    except: БЛОК_КОДА
    
В блоке `try` выполняются потенциально ошибкоопасные утверждения, в блоке `except` идёт обработка возможных ошибок,
вызванных первым блоком. Если некое утверждение в блоке `try` вызвало ошибку, то оно немеденно прерывается, следующие
за ним в этом блоке утверждения не выполняются, а управление переходит в блок `except`.

Пример:

```python
# coding: utf-8
try:
    print 1  # выполнится
    print 1 + "1"  # вызывает TypeError, НЕ выполнится
    print 2  # НЕ выполнится
except:
    print "Ошибка"  # выведет "Ошибка"
```
В результате этого кода мы увидим в консоли:

    1
    Ошибка

Если в блоке `try` ошибки не произошло, блок `except` будет проигнорирован полностью.

```python
# coding: utf-8
try:
    print 1  # выполнится
    print 1 + 1  # ошибки нет, выполнится и выведет 2
    print 2  # выполнится
except:
    print "Ошибка"  # не выполнится
```
В этом случае мы увидим:

    1
    2
    2

Если утверждение, в котором произошла ошибка, более сложное, то возможна ситуация, когда оно прервано в середине,
то есть часть его выполнилась, а оставшаяся часть -- нет. В этом случае нужно мысленно разбить утверждение на части,
 чтобы понять, в какой момент его выполнение прекратится и каков будет результат. Рассмотрим такой пример:
 
```python
# coding: utf-8
def f():
    print "В функции f()"


try:
    print "Тест"  # выполнится
    x = 1 + f()  # вызовет TypeError, так как функция f() возвращает значение None, которое нельзя сложить с числом 
    print x  # НЕ выполнится
except:
    print "Ошибка"  # не выполнится

print x  # ошибка NameError: переменная х не определена
```

Для того, чтобы определить результат сложения `1 + f()`, интерпретатору сперва необходимо *выполнить* функцию `f()`.
Исключение возникнет уже тогда, когда мы получим результат функции, но ещё до того момента, как будет выполнено присваивание
переменной `x` значения выражения с этой функцией.

Поэтому на экране мы увидим:

    Тест
    В функции f()
    Traceback (most recent call last):
    ...
    NameError: name 'x' is not defined

То есть, всё, что произошло *до* исключения, остаётся "в силе" (а именно, `print` из функции). То, что могло произойти
 после этого момента, не будь ошибки -- не реализуется: переменная `x` не создастся, так как её значение нельзя вывести.
 
Всё, что является результатом реально выполненных до ошибки 
действий в блоке `try`, будет доступно и в выполняемом блоке `except`:

```python
# coding: utf-8
try:
    x = 1
    x += "1"  # TypeError
except:
    print "Ошибка"
    assert x == 1
```
То есть, присвоенное переменной `x` до ошибки значение будет доступно и в выполняемом блоке `except`. 


## Информация об исключении

### Типы исключений

Код потенциально может вызывать разные виды ошибок, и от их типа может зависеть реакция на них. 
Скажем, при обработке ввода с клавиатуры возникающая ошибка в значении должна приводить к повторному запросу ввода,
а ошибка в количестве аргументов функции говорит о том, что программа некорректна в принципе.

Блок `except:` выполняется при любой ошибке, и это в Python считается плохим стилем: нужно перехватывать только
те ошибки, которые мы в состоянии обработать и продолжить программу.
 
Для этого в утверждении `except` можно указать тот тип ошибки, который оно будет обрабатывать: 

    try:  БЛОК_КОДА
    except ТИП_ОШИБКИ: БЛОК_КОДА
    
В таком варианте обрабатываться будет только указанный тип ошибки, ошибки всех остальных типов будут, как и прежде, 
приводить к краху программы.

Пример:

```python
# coding: utf-8
try:
    print 1 + "1"  # вызывает TypeError
except TypeError:
    print "Ошибка"  # выведет "Ошибка"

try:
    print 1 + int("x")  # вызывает ValueError -- программа завершится по ошибке
except TypeError:
    print "Ошибка"  # не выполнится
```

Некоторые известные нам типы исключений встроены в Python:

* `SyntaxError` -- ошибка синтаксиса, её обычно не перехватывают, потому что Python сделает это до вас :) файл,
  содержащий синтаксические ошибки, не может быть обработан. Хотя теоретическая возможность перехватить это исключение есть :clock2:;
* `IndentationError` -- тоже ошибка синтаксиса, возникающая при неверном количестве отступов;  
* `NameError` -- возникает при обращении к необъявленной переменной или функции;
* `ValueError` -- возникает при попытке сконвертировать в число нечисловую строку, и т.п;
* `TypeError` -- возникает при некорректных операндах операторов, несовпадающем количестве аргументов функции;
* `ZeroDivisionError` -- при делении на 0;
* `AssertionError` -- при невыполнении предположения в утверждении `assert`;
* `UnicodeDecodeError` -- при некорректной кодировке строк или невозможности привести простоую строку к строке unicode;
* `AttributeError` -- при попытке доступа к несуществующему атрибуту объекта;
* `IndexError` -- при попытке доступа к несуществующему элементу контейнера.

Помимо них, есть ещё множество других встроенных типов исключений, а также :clock2: возможность создавать свои типы, которую
мы откроем позже.

## Обработка разных исключений от одного блока `try`

Что если один блок кода в `try` потенциально может генерировать несколько типов ошибок? Мы конечно могли бы
обернуть всё утверждение `try: except XXX` в ещё одно такое же утверждение с другим типом, но к счастью есть более простой способ:
блоков `except` может быть несколько. 
Более того, последним можно указать блок `except:` *без типа* исключения,
таким образом все не перехваченные в типизированных `except` типы исключений будут перехвачены в нём:  

    try:  БЛОК_КОДА
    except ТИП_ОШИБКИ_1: БЛОК_КОДА
    except ТИП_ОШИБКИ_2: БЛОК_КОДА
    ...
    except: БЛОК_КОДА

:exclamation: При любом количестве блоков `except` в утверждении `try: except` выполняется всегда максимум 1 блок: 
либо `try`, если ошибки не было, либо первый типизированный блок `except`, тип исключения в котором совпадает с типом вызванного
исключения, либо при наличии -- нетипизированный `except`.

:exclamation: Нетипизированный блок `except` необязателен, но при его наличии он должен быть последним из `except`-блоков.
 
```python
# coding: utf-8
try:
    x = input("Введите x")
    y = input("Введите y")
    assert int(x + y) > 0 # может вызвать TypeError, ValueError или AssertionError
except TypeError:
    print "Ошибка: х и y нельзя сложить"
except ValueError:
    print "Ошибка: х и y не могут быть преобразованы в число"
except AssertionError:
    print "Ошибка: х + y не больше нуля"
except:
    print "Непредусмотренная ошибка"
```

Часто бывает интересно и даже необходимо узнать, что за ошибка произошла. Для этого *типизированное* утверждение `except` можно
записать с указанием временной переменной, в которую сохранить объект исключения. Имя переменной указывается после
 ключевого слова `as`:

    try:  БЛОК_КОДА
    except ТИП_ОШИБКИ_1 as e: БЛОК_КОДА
    except ТИП_ОШИБКИ_2 as e: БЛОК_КОДА

Имя переменной (обычно `e`, `ex` или другое) будет доступно внутри того блока `except`, в котором оно указано.
Можно (и удобно) указывать для разных блоков одно и то же имя, так как всё равно выполнится только один блок.

:point_up: В Python 2 переменная, содержащая ошибку (если ошибка произошла), будет доступна после утверждения `try: except`.
Однако в Python 3, она доступна только в том блоке `except`, в начале которого объявлена.

У переменной, хранящей объект исключения, будут доступны некоторые атрибуты плюс возможность сконвертировать
её в строку и вывести:

```python
# coding: utf-8
try:
    x = input("Введите x")
    y = input("Введите y")
    assert int(x + y) > 0 # может вызвать TypeError, ValueError или AssertionError
except TypeError as e:
    assert type(e) == TypeError
    print "Ошибка х и y нельзя сложить"
    print e  # выведет "unsupported operand type(s) for +: ..."
    print e.message  # выведет то же
    assert str(e) == e.message
except ValueError as e:
    assert type(e) == ValueError
    print "Ошибка: х и y не могут быть преобразованы в число"
except AssertionError as e:
    assert type(e) == AssertionError
    print "Ошибка: х + y не больше нуля"
except:
    print "Непредусмотренная ошибка"
```

### Общий блок `except` для нескольких типов исключений

Хорошо, но возникает вопрос: что делать, если хочется для разных типов исключений выполнить одну и ту же обработку?
Скопировать блок кода и вставить его в несколько блоков `except` с разными типами? Не нужно! В Python можно перечислить
все эти типы исключений в одном блоке `except` в виде кортежа:

```python
# coding: utf-8
try:
    x = input("Введите x")
    assert int(x) > 0 # может вызвать TypeError, ValueError или AssertionError
except (TypeError, ValueError, AssertionError) as e:
    print e
```

Часть `as e` необязательна, если объект исключения нам не нужен.

:exclamation: Хотя кортежи допускается объявлять без круглых скобок, в утверждении `except` в Python 2.7 *обязательно*
 использовать скобки вокруг списка типов исключений. Это связано с особенностью синтаксиса более старых версий Python,
 про которые можно не знать. В Python 3 скобки уже не обязательны. 

## Блок `else`

Предположим, нужно не только обработать ошибку, но и в зависимости от её наличия выполнять разные действия.

Для этого можно поступить двумя способами:
* ввести булеву переменную-флаг:
     
        error = False
        try:
            ...
        except:
            error = True
            
        if error:
            do_on_error()
        else:
            do_on_success()
            
* попробовать выполнить всё, что нужно, в блоках `try` и `except`  

        try:
            ...
            do_on_success()
        except:
            do_on_error()

Но и первый, и второй способы имеют недостатки: в первом вводится лишняя переменная и лишнее условие, 
плюс при большем, чем 1, количестве блоков `except`, нужно в
 каждом блоке продублировать присваивание `error = True`. Во втором случае, код `do_on_success()` может также
 вызвать ошибку, которая случайно попадёт в обработку в блок `except`, да и опять же возможно дублирование 
 кода `do_on_error()` при нескольких блоках обработки.
 
В Python в утверждении `try: except` предусмотрен для этой цели специальный блок `else`:
 
        try:
            ...
        except:
            do_on_error()
        else:
            do_on_success()

Блок `else` можно использовать в любом виде утверждения `try: except` *после всех* блоков `except`, и выполнится он
только в случае, если блок `try` не вызвал никакой ошибки.

Давайте добавим блок `else` в пример выше:

```python
# coding: utf-8
def f():
    print "В функции f()"


try:
    print "Тест"  # выполнится
    x = 1 + f()  # вызовет TypeError, так как функция f() возвращает значение None, которое нельзя сложить с числом 
    print x  # НЕ выполнится
except:
    print "Ошибка"  # не выполнится
else:
    print x  # НЕ выполнится
```
На экран выведется:
  
    Тест
    В функции f()

Но программа не "упадёт", потому что блок `else`, в котором использован необъявленный (в случае ошибки) 
"икс", не выполнится.

Попробуем поменять функцию, чтобы она возвращала корректное значение-число:
```python
# coding: utf-8
def f():
    print "В функции f()"
    return 10


try:
    print "Тест"  # выполнится
    x = 1 + f()  #  
    print x  # 11
except:
    print "Ошибка"  # не выполнится
else:
    print x  # 11
```
Получим на экране:

    Тест
    В функции f()
    11
    11
    
То есть, переменная `x` успешно создана и доступна в блоке `else`.

## Общий тип исключений `Exception. Тип `object`

Немного забегая вперёд, скажем, что типы исключений, как и все типы данных в Python, имеют так называемую иерархию наследования.

Существует один встроенный тип исключений -- `Exception`, который можно назвать *корневым*:
 все объекты исключений принадлежат как к своему типу, так и к типу `Exception`.
 
Это можно объяснить так: любое исключение -- это ошибка. 
При этом любое исключение -- это также и *объект*. В Python существует специальный встроенный тип `object`, который является
корневым для всех-всех типов языка. 

Аналогия из мира геометрии: любой квадрат является прямоугольником, а любой прямоугольник - геометрической фигурой. 

Важное следствие из этого конкретно для обработки исключений состоит в том, что мы можем обрабатывать исключения любых
 типов и при этом сохранять их в переменную в одном блоке `except`:
 
```python
# coding: utf-8
try:
    x = input("Введите x")
    y = input("Введите y")
    assert int(x + y) > 0 # может вызвать TypeError, ValueError или AssertionError
except Exception as e:
    print e
```

Какого бы типа ни было исключение, оно будет перехвачено и выведено.

## Вызов исключений своими руками
 