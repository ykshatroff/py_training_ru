Лекция 10. Модули. Утверждение `import` 
=========


### Значки, используемые в тексте

* :clock2: &mdash; отмечает, что высказывание не совсем верно, но будет уточнено позднее.
* :star: &mdash; выделяет определение нового понятия.
* :exclamation: &mdash; привлекает внимание к высказыванию.
* :point_up: &mdash; указывает на небольшое отступление от темы или уточнение.
* :bulb: &mdash; индикатор традиций и договорённостей. 
* :warning: &mdash; требуется осторожность: возможно, сложное высказывание.  

## Модули в Python

:star: Модуль -- это высокоуровневое средство организации кода.
 
Задачи модуля примерно те же, как и у функций, но в более крупном масштабе. А именно -- избегать повторений уже
написанного кода, использовать уже написанное с целью экономии времени и средств на повторную разработку,
организация логической структуры кода для упрощения понимания программы, а также оптимизация самой программы
по размеру и скорости (подключение нужных модулей в тех и только тех местах, где необходимо).
 
Мы уже знакомы со многими встроенными в Python "строительными блоками" программ -- 
функциями, типами и объектами данных. Однако те самые "батарейки", которые фигурируют в широко известном слогане 
"Python. Batteries Included", относятся именно к стандартным модулям, идущим в комплекте с языком. Они не являются
неотъемлемой частью языка, такой стабильной, как синтаксис, но на их наличие можно полагаться при разработке.
 
## Утверждение `import`

Что же такое модуль в Python? По сути, это объект типа "модуль", который имеет атрибуты. Однако в отличие
от встроенных идентификаторов, модуль не доступен в программе изначально. Чтобы начать работу с модулем, его
необходимо *импортировать*, то есть подключить. для этого используется утверждение `import`, синтаксис которого
 в самом простом виде состоит из ключевого слова `import` и имени модуля.
 
```python
import sys
```

При подключении модуля таким образом, он становится доступен в программе
по своему имени как переменная, а его содержимое (так называемый *интерфейс*) доступно по именам в виде атрибутов.
 
Например, в программах довольно часто возникает необходимость получить некое случайное число. Для этого Python
предоставляет модуль `random`, в котором содержится функция `randint(x, y)`, возвращающая случайное целое число, 
большее или равное x и меньшее или равное y.   
Давайте подключим этот модуль и воспользуемся функцией:

```python
import random
assert 0 <= random.randint(0, 100) <= 100
```
Все атрибуты, предоставляемые модулем, можно увидеть, как и для любых объектов, с помощью функции `dir()`

```python
import random
dir(random)
```

Теоретически, мы можем перечислить в одном утверждении `import` сразу несколько модулей, через запятую, однако
обычно это не рекомендуется.

###   Исключение `ImportError`

При попытке импортировать несуществующий модуль возникает ошибка типа `ImportError`.

## Утверждение `from x import y`

Простая форма импорта уже достаточно функциональна, но не удобна, когда имя модуля длинное и его необходимо использовать больше
 одного раза.
 
Если мы собираемся использовать атрибут (или, как часто говорят, "символ") модуля больше одного раза, для этого 
более пригодна альтернативная форма утверждения `import`, в которой непосредственно указываются импортируемые символы,
которые также станут доступны в программе как переменные, при этом сам модуль доступен **не будет**.

Синтаксис этой формы состоит из ключевого слова `from`, имени модуля, ключевого слова `import` и перечисления
импортируемых символов (одного, либо нескольких через запятую).

```python
from random import randint
assert 0 <= randint(0, 100) <= 100
assert 0 <= randint(0, 100) <= 100
random  # => NameError: имя переменной не определено
```

Для ещё одного практического примера возьмём модуль `datetime`, который содержит некоторые сервисы для работы с календарём, датой и временем. 
В этом модуле содержится тип `date`, который позволяет оперировать с датами, тип `datetime` 
(да, его название совпадает с названием модуля) для операций с датой и временем, а также крайне эффективный тип
`timedelta` для календарных вычислений на основе временн*ы*х интервалов.  

Одной из наиболее используемых функций в программе является получение текущих времени и даты. Для этого
тип `datetime` предоставляет метод `now()`, который возвращает объект, имеющий атрибуты для доступа к значениям
года, месяца, числа, часов, минут и секунд. Также бывает интересно узнать, например, дату, которая настанет
через 30 календарных дней. Это позволяет сделать объект `timedelta`, которому можно передать именованный аргумент
`days=30`.

В простой форме импорта мы бы написали так:
 
```python
import datetime
print datetime.datetime.now() + datetime.timedelta(days=30)  # 2016-12-20 21:04:37.293030
```

Однако не многовато ли тут слов `datetime`? Давайте чуть упростим:

```python
from datetime import datetime, timedelta
print datetime.now() + timedelta(days=30)  # 2016-12-20 21:04:37.293030
```
Так поприятнее выглядит, не правда ли?

### Переименование импортируемых символов

При импорте модуля или символа из него, как и при объявлении новой переменной, 
все ранее объявленные с этим именем объекты становятся недоступны. 
Есть только одна проблема: а что если в других модулях содержатся такие же имена символов?
Мы конечно можем сохранить подключенный символ под другим именем... Но есть более простой путь.

Для разрешения подобных конфликтов, а также местами просто для удобства, мы можем переименовывать импортируемые
символы прямо в утверждении, добавляя после подключаемого символа ключевое слово `as` и новое имя. После этого
символ будет доступен *только* по новому имени, никак не влияя на объекты под старым.
 
```python
datetime = "A"
timedelta = "B"
from datetime import datetime as dt, timedelta as td
assert datetime == "A" and timedelta == "B"
print dt.now() + td(days=30)  # 2016-12-20 21:04:37.293030
```

Переименование относится только к непосредственно примыкающему символу. Оно также может использоваться и в простой форме
импорта: `import random as rnd`.

## Некоторые популярные модули

В стандартной поставке Python более сотни модулей для работы с различными типами данных, сервисами операционной системы,
для тестирования, связи по сети, и даже для проектирования графических интерфейсов. Однако большинство из них
требует специальных знаний в области применения, выходящих далеко за рамки изучения Python.

Впрочем, есть и такие модули, которые настолько важны, что без знания их назначения и хотя бы базового интерфейса
разобраться в средней программе будет затруднительно.

### Модуль `datetime`

Один из таких модулей -- указанный `datetime`. Его главный функционал содержится в объектах `date`, `datetime` и `timedelta`.
 
*   Тип `date` -- объекты этого типа имеют атрибуты `year`, `month`, `day` и  
    метод `weekday()` (порядковый номер дня недели, начиная с 0=понедельник). Чтобы создать объект из типа, необходимо
    вызвать функцию-конструктор `date()` с аргументами `year`, `month`, `day`:

    ```python
    from datetime import date
    mydate = date(2016, 11, 20)
    assert mydate.year == 2016 
    assert mydate.month == 11 
    assert mydate.day == 20 
    assert mydate.weekday() == 0 
    ```

* Метод `date.today()`, являющийся именно методом *типа* `date`, а не объекта -- возвращает объект типа `date`,
  содержащий данные о сегодняшнем дне;

* Тип `datetime`, являющийся расширением типа `date`, объект типа `datetime`
  имеет те же атрибуты, что и `date`, плюс атрибуты  `hour`, `minute`, `second` и `microsecond`.
  Создать объект `datetime` можно, вызвав функцию `datetime()` с такими же параметрами, что и `date()` и
  опциональными параметрами: час, минута, секунда, микросекунда, часовая зона;
  
* Метод `datetime.now()`, являющийся методом *типа* `datetime`, а не объекта -- возвращает объект типа `datetime`,
  который содержит данные о моменте вызова;
  
*   Тип (класс) `timedelta`, объекты которого представляют собой разность дат: "арифметическая" разность двух
    объектов `date` и/или `datetime` является объектом типа `timedelta`, а объекты дат можно складывать или вычитать
    с `timedelta`-объектами. Вручную создать объект `timedelta` можно, передав функции-конструктору типа `timedelta`
    именованные аргументы `days`, `seconds` и/или `microseconds`;

    ```python
    from datetime import date, timedelta
    mydate = date(2016, 11, 20)
    mydate_tomorrow = mydate + timedelta(days=1)
    assert mydate_tomorrow == date(2016, 11, 21) 
    assert mydate_tomorrow - mydate == timedelta(days=1)
    ```

### Модуль `time`

Модуль `time` знаменит одной своей функцией - `time()`, которая возвращает текущую временн*у*ю метку в виде вещественного
числа, равного количеству секунд, прошедших с 01.01.1970, с точностью до микросекунды и выше.
Эту временную метку используют много где, в том числе, например, для тестов производительности: взяв разность двух
 меток, можно с высокой точностью сказать, сколько времени между ними истекло.
 
Также важна функция `sleep()`, которая принимает один аргумент -- число секунд, в течение которых программа будет просто
ничего не делать ("спать").

### Модуль `re`

В этом модуле содержится функционал *регулярных выражений* -- операции со строками, такие как поиск и замена по образцу,
например, всех символов, являющихся строчными буквами, или цифрами, и т.п.
 
### Модуль `sys`

Одной из самых простых доступный функций этого модуля является определение версии Python:

```python
import sys
print sys.version
print sys.version_info
```

Также в этом модуле содержится список аргументов командной строки выполняемой программы (в атрибуте `argv`), метод
 `exit()`, позволяющий досрочно завершить программу, и многие другие полезные вещи.
 
### Модуль `os`

Модуль, по названию содержащий инструменты для работы с операционной системой: с файлами и каталогами, командами ОС
и переменными окружения.

* `os.environ` -- словарь, содержащий переменные окружения;
* `os.rename()`, `os.remove()` -- функции для переименования и удаления файлов;
* `os.mkdir()`, `os.rmdir()` -- функции для создания и удаления каталога;
* `os.listdir()` -- функция для получения списка файлов в каталоге;
* `os.stat()` -- функция для получения информации о файле, возвращает словарь, одним из ключей которого является
    `st_size` -- размер файла в байтах, также есть информация о дате создания и модификации, и прочее;

и т.п.


### Модуль `math`

Модуль `math` содержит разнообразные математические функции: подсчёт логарифмов, функции тригонометрии, а также
 числа `pi` и `e`.
 
 
### Модуль `urllib2`

Этот модуль позволяет работать с URL почти так же, как с файлами: открывать URL как файл, используя
функцию `urllib2.urlopen(url)`, и читать данные из полученного объекта как из файла с помощью метода `read()`.

## Иерархия модулей. Путь к модулю

Модуль является высшим типом организации кода в Python: синтаксически модуль может содержать дрimугие объекты, но ни один
 другой тип данных не может содержать модули -- кроме других модулей.
 
Структура, в которой модуль содержит другой модуль (как и в общем, когда некий объект содержит другие объекты того же типа), 
называется иерархической. Иерархия модулей -- это "дерево", начинающееся от корневого модуля, который содержит 
подмодули-"ветки", которые в свою очередь также могут содержать подмодули.

При наличии у модуля подмодулей, для их использования недостаточно импортировать родительский модуль, так как
он не "знает" о наличии у него подмодулей, т.е. не имеет соответствующих атрибутов. Для обозначения необходимости
импортировать подмодуль, в утверждении `import` мы должны указать так называемый "путь" к нему, то есть последовательность
родительских модулей в иерархии. Синтаксически это выглядит так же, как будто подмодули являются атрибутами своих
родительских модулей: их имена следуют от корневого к импортируемому, разделяемые точкой.

```python
import xml.etree
assert xml.etree.__name__ == 'xml.etree'
assert xml.__name__ == 'xml'
```
В результате, подмодуль `xml.etree` станет доступен в программе по своему *полному пути* (иначе -- *абсолютному пути*),
то есть с указанием полной иерархии. Этот самый путь мы можем увидеть в атрибуте `__name__` объекта модуля.

При таком указании импорта, также будет подключён и модуль `xml`, так как его наличие обязательно для определения 
его "атрибута" `etree`. 

Альтернативно этому, можно подключить непосредственно подмодуль `etree` из модуля `xml` в утверждении `from .. import`:

```python
from xml import etree
assert etree.__name__ == 'xml.etree'
```
В этом случае переменная `xml` не будет создаваться за ненадобностью, сам модулб доступен через простую переменную, 
в то же время абсолютный путь модуля не поменялся.
 
Если иерархия модулей насчитывает более двух, то в `from` мы также можем указать иерархию через точку:
```python
from xml.dom import minidom
assert minidom.__name__ == 'xml.dom.minidom'
```

Что если мы хотим подключить не подмодуль, а сразу некий объект из него? 
Такая возможность есть: мы можем импортировать любой объект непосредственно из подмодуля
в утверждении `from ... import`: `from` <иерархия модулей> `import` <имя объекта>.
 
Продемонстрируем на примере функции `parseString()` из модуля `xml.dom.minidom`, которая "переводит" строку в xml-формате
в набор Python-объектов с удобным для работы интерфейсом: 

```python
from xml.dom.minidom import parseString
```

Такова в общем механика работы с готовыми модулями в Python.

## Пакеты. Установка внешних модулей

Однако, Python не ограничивается модулями из стандартного комплекта. Огромное количество внешних модулей доступно в виде
*пакетов*.

Для установки пакета необходимо использовать одну из двух утилит, идущих в комплекте с Python:
либо `pip`, либо `easy_install`; впрочем, можно и положиться на возможности PyCharm.

Например, для установки пакета `requests`, который позволяет очень эффективно получать данные из интернета,
достаточно написать в командной строке `easy_install requests`, и утилита скачает и установит последнюю версию пакета
с сайта https://pypi.python.org , на котором находится основное хранилище внешних пакетов для Python.
После установки модуль `requests` будет доступен как корневой: `import requests`.
 
Для более сложной установки, с учётом версий и зависимостей, рекомендуется использовать утилиту `pip`, которая правда
 довольно капризна и требует определённых познаний о формате указания версий, но в базовом виде установка пакета `requests` версии 2.10
  выглядела бы так: `pip install requests==2.10`.
  
## Создание собственных модулей

С не-Python точки зрения, модуль Python -- это чаще всего некий файл, имя которого оканчивается на `.py`, а имя модуля --
это всё, что предшествует точке в имени файла. При этом очевидно, имя файла должно состоять только из символов, допустимых
для имён переменных, иначе такой модуль будет невозможно подключить.

Например, файл `program1.py` может быть доступен в виде модуля `program1`.
 
:point_up: Названия модулей обычно состоят из букв нижнего регистра и, возможно, знаков подчёркивания.

Как сделать такой модуль доступным? Очень просто: все подобные файлы в текущем каталоге можно импортировать как модули
из командной строки и из других файлов в этом каталоге.


Все переменные и функции, объявленные непосредственно в таком файле (то есть на уровне модуля), 
будут являться атрибутами модуля.
 

Пример: 

Файл  `program1.py`

```
CONSTANT = 100 
```
Файл  `program2.py`

```
import program1
assert program1.CONSTANT == 100 
```

```
>>> import program1 
```

### Иерархия модулей 

Так как файл не может содержаться в другом файле, то родительским модулем может быть только каталог.
Для пометки каталога как модуля, содержащего файлы-подмодули (или каталоги-подмодули), необходимо доавить в этот
каталог специальный файл `__init__.py` -- этот файл может быть пустым, в таком случае у самого модуля не будет
атрибутов, а могут быть только подмодули. Либо можно в этом файле задавать атрибуты, как для обычного модуля.

Таким образом, собственноручная иерархия модулей и объектов состоит из: 
* каталогов, содержащих файлы `__init__.py`, неограниченной вложенности,
* файлов с расширением `.py` -- конечных подмодулей в иерархии модулей,
* объектов в модулях -- конечных объектов в иерархии.

### Абсолютный и относительный импорт

До данного момента мы использовали для импорта объектов абсолютный, или полный, путь в иерархии.
Его удобно использовать, когда наша программа лежит в одном корневом каталоге.

Однако предположим, у нас есть глубоко вложенные подмодули, которые могут и не знать о том, какие родительские модули
их используют.

Для таких ситуаций используется относительный импорт. Относительный он потому, что имя подключаемого модуля
разрешается относительно текущего модуля.

Относительный импорт отличается от абсолютного тем, что перед названием модуля ставится точка (или несколько точек).

Одна точка означает "подключить модуль, который находится на том же уровне иерархии, что и текущий модуль", то есть,
физически в том же каталоге.

Две точки означают, "искать модуль в иерархии на уровень выше" -- то есть, в родительском каталоге. И так далее.

Остальная часть импорта -- путь к подключаемому модулю *относительно* указанного уровня иерархии.
 
При этом в относительных импортах нам не удастся импортировать стандартные или установленные извне модули, 
так как физически они расположены
совершенно в другом каталоге. 

Есть ещё одно существенное ограничение широты применения относительного импорта: он может использоваться
 только в подмодулях. Использование его в модулях верхнего уровня вызовет ошибку `ImportError`. Также
 ошибкой завершится попытка импорта уровнем выше, чем второй уровень вложенности.   
 

[Следующая лекция](./lecture_11.md) [Оглавление](./README.md) [Предыдущая лекция](./lecture_09.md) 
