Лекция 10. Модули. Утверждение `import` 
=========


### Значки, используемые в тексте

* :clock2: &mdash; отмечает, что высказывание не совсем верно, но будет уточнено позднее.
* :star: &mdash; выделяет определение нового понятия.
* :exclamation: &mdash; привлекает внимание к высказыванию.
* :point_up: &mdash; указывает на небольшое отступление от темы или уточнение.
* :bulb: &mdash; индикатор традиций и договорённостей. 
* :warning: &mdash; требуется осторожность: возможно, сложное высказывание.  

## Модули в Python

:star: Модуль &mdash; это высокоуровневое средство организации кода.
 
Задачи модуля примерно те же, как и у функций, но в более крупном масштабе. А именно &mdash; избегать повторений уже
написанного кода, использовать уже написанное с целью экономии времени и средств на повторную разработку,
организация логической структуры кода для упрощения понимания программы, а также оптимизация самой программы
по размеру и скорости (подключение нужных модулей в тех и только тех местах, где необходимо).
 
Мы уже знакомы со многими встроенными в Python "строительными блоками" программ &mdash; 
функциями, типами и объектами данных. Однако те самые "батарейки", которые фигурируют в широко известном слогане 
"Python. Batteries Included", относятся именно к стандартным модулям, идущим в комплекте с языком. Они не являются
неотъемлемой частью языка, такой стабильной, как синтаксис, но на их наличие можно полагаться при разработке.
 
## Утверждение `import`

Что же такое модуль в Python? По сути, это объект типа "модуль", который имеет атрибуты. Однако в отличие
от встроенных идентификаторов, модуль не доступен в программе изначально. Чтобы начать работу с модулем, его
необходимо *импортировать*, то есть подключить. Для этого используется утверждение `import`, синтаксис которого
 в самом простом виде состоит из ключевого слова `import` и имени модуля.
 
```python
import sys
```

При подключении модуля таким образом, он становится доступен в программе
по своему имени как переменная, а его содержимое (так называемый *интерфейс*) доступно по именам в виде атрибутов.
 
Например, в программах довольно часто возникает необходимость получить некое случайное число. Для этого Python
предоставляет модуль `random`, в котором содержится функция `randint(x, y)`, возвращающая случайное целое число, 
большее или равное `x` и меньшее или равное `y`.   
Давайте подключим этот модуль и воспользуемся функцией:

```python
import random
assert 0 <= random.randint(0, 100) <= 100
```
Все атрибуты, предоставляемые модулем, можно увидеть, как и для любых объектов, с помощью функции `dir()`:

```python
import random
dir(random)
```

:point_up: Теоретически, мы можем перечислить в одном утверждении `import` сразу несколько модулей, через запятую, однако
обычно это не рекомендуется.

###   Исключение `ImportError`

При попытке импортировать несуществующий модуль возникает исключение типа `ImportError`. Оно также возникает
и в некоторых других случаях, связанных с ошибками импорта.

## Утверждение `from x import y`

Простая форма импорта уже достаточно функциональна, но не удобна, когда имя модуля длинное и его необходимо использовать больше
 одного раза.
 
Если мы собираемся использовать атрибут (или, как часто говорят, "символ") модуля больше одного раза, для этого 
более пригодна альтернативная форма утверждения `import`, в которой непосредственно указываются импортируемые символы,
которые также станут доступны в программе как переменные, при этом сам модуль доступен **не будет**.

Синтаксис этой формы состоит из ключевого слова `from`, имени модуля, ключевого слова `import` и перечисления
импортируемых символов (одного, либо нескольких через запятую).

```python
from random import randint
assert 0 <= randint(0, 100) <= 100
assert 0 <= randint(0, 100) <= 100
random  # => NameError: имя переменной не определено
```

Для ещё одного практического примера возьмём модуль `datetime`, который содержит некоторые сервисы для работы с календарём, датой и временем. 
В этом модуле содержится тип `date`, который позволяет оперировать с датами, тип `datetime` 
(да, его название совпадает с названием модуля) для операций с датой и временем, а также крайне эффективный тип
`timedelta` для календарных вычислений на основе временн*ы*х интервалов.  

Одной из наиболее используемых функций в программе является получение текущих времени и даты. Для этого
тип `datetime` предоставляет метод `now()`, который возвращает объект, имеющий атрибуты для доступа к значениям
года, месяца, числа, часов, минут и секунд. Также бывает интересно узнать, например, дату, которая настанет
через 30 календарных дней. Это позволяет сделать объект `timedelta`, которому можно передать именованный аргумент
`days=30`.

В простой форме импорта мы бы написали так:
 
```python
import datetime
print datetime.datetime.now() + datetime.timedelta(days=30)  # 2016-12-20 21:04:37.293030
```

Однако не многовато ли тут слов `datetime`? Давайте чуть упростим:

```python
from datetime import datetime, timedelta
print datetime.now() + timedelta(days=30)  # 2016-12-20 21:04:37.293030
```
Так поприятнее выглядит, не правда ли?

### Переименование импортируемых символов

При импорте модуля или символа из него, как и при объявлении новой переменной, 
все ранее объявленные с этим именем объекты становятся недоступны. 
Есть только одна проблема: а что если в других модулях содержатся такие же имена символов?
Мы конечно можем сохранить подключенный символ под другим именем... Но есть более простой путь.

Для разрешения подобных конфликтов, а также местами просто для удобства, мы можем переименовывать импортируемые
символы прямо в утверждении, добавляя после подключаемого символа ключевое слово `as` и новое имя. После этого
символ будет доступен *только* по новому имени, никак не влияя на объекты под старым.
 
```python
datetime = "A"
timedelta = "B"
from datetime import datetime as dt, timedelta as td
assert datetime == "A" and timedelta == "B"
print dt.now() + td(days=30)  # 2016-12-20 21:04:37.293030
```

Переименование относится только к непосредственно примыкающему символу. Оно также может использоваться и в простой форме
импорта: `import random as rnd`.

### Импорт всех символов из модуля

За очень редким исключением, в одном месте программы может понадобиться только небольшой набор символов из одного модуля.
Но бывает, что нужны сразу все, и перечислять их в утверждении `from ... import` утомительно. С этой целью существует
сокращённая форма специально для импорта сразу всех :clock2: символов из модуля: `from mymodule import *`.

В общем случае эта форма крайне не рекомендуется к использованию, так как а) явное лучше, чем неявное, б) потенциально
возникает опасность "затенить" уже объявленные (или заимпортированные) ранее переменные или просто замусорить 
таблицу символов, негативно влияя на производительность и размер памяти. Но при необходимости, нужно помнить о следующем:
импортируются не *вообще все* объекты, а только те, имена которых:
* не начинаются с символа `_` (подчерк) &mdash;  подобные названия считаются скрытыми,
* явно разрешены для подобного импорта в самом модуле. Об этом поговорим позже.

То есть, импорт "всего" через `*` импортирует далеко не *всё*, что можно импортировать явно по именам.

## Иерархия модулей. Путь к модулю

Модуль является высшим типом организации кода в Python: синтаксически модуль может содержать дрimугие объекты, но ни один
 другой тип данных не может содержать модули &mdash; кроме других модулей.
 
Структура, в которой модуль содержит другой модуль (как и в общем, когда некий объект содержит другие объекты того же типа), 
называется иерархической. Иерархия модулей &mdash; это "дерево", начинающееся от корневого модуля, который содержит 
подмодули-"ветки", которые в свою очередь также могут содержать подмодули.

При наличии у модуля подмодулей, для их использования недостаточно импортировать родительский модуль, так как
он не "знает" о наличии у него подмодулей, т.е. не имеет соответствующих атрибутов. Для обозначения необходимости
импортировать подмодуль, в утверждении `import` мы должны указать так называемый "путь" к нему, то есть последовательность
родительских модулей в иерархии. Синтаксически это выглядит так же, как будто подмодули являются атрибутами своих
родительских модулей: их имена следуют от корневого к импортируемому, разделяемые точкой.

```python
import xml.etree
assert xml.etree.__name__ == 'xml.etree'
assert xml.__name__ == 'xml'
```
В результате, подмодуль `xml.etree` станет доступен в программе по своему *полному пути* (иначе &mdash; *абсолютному пути*),
то есть с указанием полной иерархии. Этот самый путь мы можем увидеть в атрибуте `__name__` объекта модуля.

При таком указании импорта, также будет подключён и модуль `xml`, так как его наличие обязательно для определения 
его "атрибута" `etree`. 

Альтернативно этому, можно подключить непосредственно подмодуль `etree` из модуля `xml` в утверждении `from .. import`:

```python
from xml import etree
assert etree.__name__ == 'xml.etree'
```
В этом случае переменная `xml` не будет создаваться за ненадобностью, сам модулб доступен через простую переменную, 
в то же время абсолютный путь модуля не поменялся.
 
Если иерархия модулей насчитывает более двух, то в `from` мы также можем указать иерархию через точку:
```python
from xml.dom import minidom
assert minidom.__name__ == 'xml.dom.minidom'
```

Что если мы хотим подключить не подмодуль, а сразу некий объект из него? 
Такая возможность есть: мы можем импортировать любой объект непосредственно из подмодуля
в утверждении `from ... import`: `from` <иерархия модулей> `import` <имя объекта>.
 
Продемонстрируем на примере функции `parseString()` из модуля `xml.dom.minidom`, которая "переводит" строку в xml-формате
в набор Python-объектов с удобным для работы интерфейсом: 

```python
from xml.dom.minidom import parseString
```

Такова в общем механика работы с готовыми модулями в Python.

## Пакеты. Установка внешних модулей

Однако, Python не ограничивается модулями из стандартного комплекта. Огромное количество внешних модулей доступно в виде
*пакетов*.

Для установки пакета необходимо использовать одну из двух утилит, идущих в комплекте с Python:
либо `pip`, либо `easy_install`; впрочем, можно и положиться на возможности PyCharm.

Например, для установки пакета `requests`, который позволяет очень эффективно получать данные из интернета,
достаточно написать в командной строке `easy_install requests`, и утилита скачает и установит последнюю версию пакета
с сайта https://pypi.python.org , на котором находится основное хранилище внешних пакетов для Python.
После установки модуль `requests` будет доступен как корневой: `import requests`.
 
Для более сложной установки, с учётом версий и зависимостей, рекомендуется использовать утилиту `pip`, которая правда
 довольно капризна и требует определённых познаний о формате указания версий, но в базовом виде установка пакета `requests` версии 2.10
  выглядела бы так: `pip install requests==2.10`.
  
Названия *пакетов*, в отличие от имён модулей, переменных и объектов внутри Python, регистронезависимы,
то есть `pip install REQUESTS` или `pip install REquESts` одинаково успешно установит нужный пакет.
Более того, дефисы (минусы) и подчерки в названиях пакетов также взаимозаменяемы, например пакет
`MySQL-python` можно установить как `mysql_python`.

Удалить установленный пакет можно командой `pip uninstall`.
  
### Файл зависимостей

Часто работа с проектом на Python требует наличия нескольких внешних пакетов. При этом если над проектом работает
несколько человек, то эти пакеты должны быть установлены у всех. Для того, чтобы указать перечень пакетов, необходимых
проекту, используется специальный файл зависимостей, чаще всего этот файл располагается в корне проекта и называется
`requirements.txt`, но это название не форсируется.

В файле зависимостей указывается &mdash; по одному пакету в строке &mdash; список пакетов с опциональным суффиксом версии, 
которые должны быть установлены с помощью команды `pip install -r requirements.txt` из командной строки, либо
 при пользовании PyCharm достаточно просто подключить этот файл в настройках: *Settings - Tools - Python Integrated Tools -
 Package requirements file*.

Создание и подключение такого файла &mdash; практически необходимость для любого современного проекта.

### Версии пакетов

Суффиксы версий пакетов, используемые в файле зависимостей, допустимы и при установке пакетов из командной строки,
но именно в файле с ними чаще всего приходится иметь дело. Эти суффиксы просты и представляют собой знаки сравнения
 `>`, `>=`, `==`, `<` или `<=`, за которыми следует версия в число-точечном представлении, например `requests>=2.10.0`
 обозначает зависимость от пакета requests версии 2.10.0 и выше.


### Виртуальные окружения

Как следствие того, что в разных проектах может требоваться набор несовместимых версий пакетов или даже один и тот же
пакет разных версий, а системный интерпретатор Python (данной версии) один и в системе только одно хранилище пакетов для него,
необходимо как-то отделять установки для разных проектов друг от друга. Также для модификации системных модулей часто
 требуются права администратора, отсутствие которых сильно усложняет процесс установки или вообще делает его невозможным.

Для решения этоих проблем существует полезный инструмент --
виртуальное окружение, которое представляет из себя полностью выделенный каталог, в котором находится как сам
интерпретатор (при этом можно указать его версию, если в системе их несколько) и инсталлятор, 
так и стандартные модули, и специально
выделенный каталог для внешних модулей. В совокупности эти вещи и составляют окружение. 
Они все полностью (за крайне незначительным исключением в Unix) 
независимы от системных окружений и друг от друга.

Достаточно в системное окружение установить пакет `virtualenv`, и после этого
можно создавать сколько угодно виртуальных окружений:

```
# pip install virtualenv
$ virtualenv -p python2.7 myenv
```
В данном примере показана команда установки системного пакета `virtualenv` (отмечено как `#` &mdash; означает запуск от
администратора), и затем (от обычного пользователя, обозначено как `$`) 
подготовка виртуального окружения с названием `myenv` в текущем каталоге, при этом в нём
будет создан подкаталог `myenv`, где и будут находиться все файлы окружения. 
 
Однако чтобы использовать установленное окружение в проекте, его надо *активировать*.
Возможно, вам не придётся работать с проектами на python из командной строки, но вдруг &mdash; на этот случай,
необходимо запустить файл `myenv/bin/activate` в Windows, или сделать `source myenv/bin/activate` в Unix. 

Эта команда добавит путь до интерпретатора `python` и инсталлятора `pip` в PATH, и укажет им,
откуда именно брать библиотеки.
 
В PyCharm же создание виртуальных окружений можно делать из настроек: 
*Settings - Project: myproject - Project interpreter - "звёздочка" выпадающее меню - create virtualenv*.

Полное руководство по virtualenv можно [посмотреть тут](https://virtualenv.pypa.io/en/stable/userguide/).

## Создание собственных модулей

С не-Python точки зрения, модуль Python &mdash; это чаще всего некий файл, имя которого оканчивается на `.py`, а имя модуля --
это всё, что предшествует точке в имени файла. При этом очевидно, имя файла должно состоять только из символов, допустимых
для имён переменных, иначе такой модуль будет невозможно подключить.

Например, файл `program1.py` может быть доступен в виде модуля `program1`.
 
:point_up: Названия модулей обычно состоят из букв нижнего регистра и, возможно, знаков подчёркивания.

Как сделать такой модуль доступным? Очень просто: все подобные файлы в текущем каталоге можно импортировать как модули
из командной строки и из других файлов в этом каталоге.


Все переменные и функции, объявленные непосредственно в таком файле (то есть на уровне модуля), 
будут являться атрибутами модуля.
 

Пример: 

Файл  `program1.py`

```
CONSTANT = 100 
```
Файл  `program2.py`

```
import program1
assert program1.CONSTANT == 100 
```

```
>>> import program1 
```

### Иерархия модулей 

Так как файл не может содержаться в другом файле, то родительским модулем может быть только каталог.
Для пометки каталога как модуля, содержащего файлы-подмодули (или каталоги-подмодули), необходимо доавить в этот
каталог специальный файл `__init__.py` &mdash; этот файл может быть пустым, в таком случае у самого модуля не будет
атрибутов, а могут быть только подмодули. Либо можно в этом файле задавать атрибуты, как для обычного модуля.

Таким образом, собственноручная иерархия модулей и объектов состоит из: 
* каталогов, содержащих файлы `__init__.py`, неограниченной вложенности,
* файлов с расширением `.py` &mdash; конечных подмодулей в иерархии модулей,
* объектов в модулях &mdash; конечных объектов в иерархии.

### Абсолютный и относительный импорт

До данного момента мы использовали для импорта объектов абсолютный, или полный, путь в иерархии.
Его удобно использовать, когда наша программа лежит в одном корневом каталоге.

Однако предположим, у нас есть глубоко вложенные подмодули, которые могут и не знать о том, какие родительские модули
их используют.

Для таких ситуаций используется относительный импорт. Относительный он потому, что имя подключаемого модуля
разрешается относительно текущего модуля.

Относительный импорт отличается от абсолютного тем, что перед названием модуля ставится точка (или несколько точек).

Одна точка означает "подключить модуль, который находится на том же уровне иерархии, что и текущий модуль", то есть,
физически в том же каталоге.

Две точки означают, "искать модуль в иерархии на уровень выше" &mdash; то есть, в родительском каталоге. И так далее.

Остальная часть импорта &mdash; путь к подключаемому модулю *относительно* указанного уровня иерархии.
 
При этом в относительных импортах нам не удастся импортировать стандартные или установленные извне модули, 
так как физически они расположены
совершенно в другом каталоге. 

Есть ещё одно существенное ограничение широты применения относительного импорта: он может использоваться
 только в подмодулях. Использование его в модулях верхнего уровня вызовет ошибку `ImportError`. Также
 ошибкой завершится попытка импорта уровнем выше, чем второй уровень вложенности.   
 
### Циклический импорт

Что будет, если в одном нашем модуле мы импортируем другой, который, в свою очередь, зависит от первого (то есть,
либо импортирует его непосредственно, либо использует третьи модули, которые зависят от первого)?
Будет, совершенно логично, ошибка `ImportError`. Это случай циклического импорта, или круговой зависимости. 
При этом далеко не всегда сразу понятно, 
что в данном случае является её причиной. Если модуль с таким именем точно есть &mdash; то скорее всего, дело именно в этом.
 
Но иногда нам очень надо в одном модуле использовать интерфейс другого, а в другом &mdash; первого. 

Чтобы избежать ошибки круговой зависимости, мы можем импортировать символы в одном из этих модулей не
на уровне модуля (т.е. не в наружном блоке кода с нулевым отступом), а внутри функции: импорт
происходит только тогда, когда программа выполняет это утверждение &mdash; то есть, во время вызова функции, 
а не её объявления. 

 
### Автоматическая компиляция модулей

Создавая собственные модули, вы можете заметить, что в момент запуска программы, их импортирующей, рядом 
с файлами `*.py` в файловой системе появляются файлы `*.pyc` (или каталог `__pycache__` с такими файлами в Python 3).

Эти файлы не что иное, как модули, преобразованные в бинарный формат (скомпилированные) для ускорения импорта.
Такие файлы создаются автоматически интерпретатором только во время импорта (во время запуска файла &mdash; не создаются).
Удалять их не обязательно, так как они будут обновляться при обновлении исходного кода. Но их наличие в проекте в
системе контроля версий нежелательно, их обычно добавляют в список ignore.

Такие же файлы создаются интерпретатором и для стандартных и внешних модулей.

## Некоторые популярные модули

### Стандартные модули Python

В стандартной поставке Python более сотни модулей для работы с различными типами данных, сервисами операционной системы,
для тестирования, связи по сети, и даже для проектирования графических интерфейсов. Однако большинство из них
требует специальных знаний в области применения, выходящих далеко за рамки изучения Python.

Впрочем, есть и такие модули, которые настолько важны, что без знания их назначения и хотя бы базового интерфейса
разобраться в средней программе будет затруднительно.

#### Модуль `datetime`

Один из таких модулей &mdash; указанный `datetime`. Его главный функционал содержится в объектах `date`, `datetime` и `timedelta`.
 
*   Тип `date` &mdash; объекты этого типа имеют атрибуты `year`, `month`, `day` и  
    метод `weekday()` (порядковый номер дня недели, начиная с 0=понедельник). Чтобы создать объект из типа, необходимо
    вызвать функцию-конструктор `date()` с аргументами `year`, `month`, `day`:

    ```python
    from datetime import date
    mydate = date(2016, 11, 20)
    assert mydate.year == 2016 
    assert mydate.month == 11 
    assert mydate.day == 20 
    assert mydate.weekday() == 0 
    ```

* Метод `date.today()`, являющийся именно методом *типа* `date`, а не объекта &mdash; возвращает объект типа `date`,
  содержащий данные о сегодняшнем дне;

* Тип `datetime`, являющийся расширением типа `date`, объект типа `datetime`
  имеет те же атрибуты, что и `date`, плюс атрибуты  `hour`, `minute`, `second` и `microsecond`.
  Создать объект `datetime` можно, вызвав функцию `datetime()` с такими же параметрами, что и `date()` и
  опциональными параметрами: час, минута, секунда, микросекунда, часовая зона;
  
* Метод `datetime.now()`, являющийся методом *типа* `datetime`, а не объекта &mdash; возвращает объект типа `datetime`,
  который содержит данные о моменте вызова;
  
*   Тип (класс) `timedelta`, объекты которого представляют собой разность дат: "арифметическая" разность двух
    объектов `date` и/или `datetime` является объектом типа `timedelta`, а объекты дат можно складывать или вычитать
    с `timedelta`-объектами. Вручную создать объект `timedelta` можно, передав функции-конструктору типа `timedelta`
    именованные аргументы `days`, `seconds` и/или `microseconds`;

    ```python
    from datetime import date, timedelta
    mydate = date(2016, 11, 20)
    mydate_tomorrow = mydate + timedelta(days=1)
    assert mydate_tomorrow == date(2016, 11, 21) 
    assert mydate_tomorrow - mydate == timedelta(days=1)
    ```

#### Модуль `time`

Модуль `time` знаменит одной своей функцией - `time()`, которая возвращает текущую временн*у*ю метку в виде вещественного
числа, равного количеству секунд, прошедших с 01.01.1970, с точностью до микросекунды и выше.
Эту временную метку используют много где, в том числе, например, для тестов производительности: взяв разность двух
 меток, можно с высокой точностью сказать, сколько времени между ними истекло.
 
Также важна функция `sleep()`, которая принимает один аргумент &mdash; число секунд, в течение которых программа будет просто
ничего не делать ("спать").

#### Модуль `re`

В этом модуле содержится функционал *регулярных выражений* &mdash; операции со строками, такие как поиск и замена по образцу,
например, всех символов, являющихся строчными буквами, или цифрами, и т.п. Пример такого выражения:

```python
import re
assert re.sub(r'[^a-z]', '*', "This Is A Test") == "*his**s****est" 
```

#### Модуль `sys`

Одной из самых простых доступный функций этого модуля является определение версии Python:

```python
import sys
print sys.version
print sys.version_info
```

Также в этом модуле содержится список аргументов командной строки выполняемой программы (в атрибуте `argv`), метод
 `exit()`, позволяющий досрочно завершить программу, и многие другие полезные вещи.
 
#### Модуль `os`

Модуль, по названию содержащий инструменты для работы с операционной системой: с файлами и каталогами, командами ОС
и переменными окружения.

* `os.environ` &mdash; словарь, содержащий переменные окружения;
* `os.rename()`, `os.remove()` &mdash; функции для переименования и удаления файлов;
* `os.mkdir()`, `os.rmdir()` &mdash; функции для создания и удаления каталога;
* `os.listdir()` &mdash; функция для получения списка файлов в каталоге;
* `os.stat()` &mdash; функция для получения информации о файле, возвращает словарь, одним из ключей которого является
    `st_size` &mdash; размер файла в байтах, также есть информация о дате создания и модификации, и прочее;

и т.п.


#### Модуль `math`

Модуль `math` содержит разнообразные математические функции: подсчёт логарифмов, функции тригонометрии, а также
 числа `pi` и `e`.
 
 
#### Модуль `urllib2`

Этот модуль позволяет работать с URL почти так же, как с файлами: открывать URL как файл, используя
функцию `urllib2.urlopen(url)`, и читать данные из полученного объекта как из файла с помощью метода `read()`.

### Внешние модули

Внешних модулей сотни и тысячи &mdash; репозиторий под названием PyPI ([Python Package Index](https://pypi.python.org)) 
постоянно пополняется, и если вы о чём-то задумались, то с большой вероятностью вы найдёте это там.

#### `requests`

Очень популярный модуль для выполнения запросов в интернете (по протоколу HTTP/HTTPS) &mdash; это модуль `requests`.

Его очень простой интерфейс в совокупности с огромным потенциалом обеспечил ему 
[второе место](http://pypi-ranking.info/alltime) по популярности среди прикладных модулей (модули six и setuptools 
скорее относятся к инфраструктурным).

#### pytest

Модуль для тестирования написанного кода, заменяющий стандартный модуль `unittest` и предоставляющий также более простой,
ясный и функциональный интерфейс. Для чего и как тестировать, мы обязательно поговорим позже.

#### Pillow

Модуль для работы с файлами растровых изображений разных форматов. Очень простой интерфейс и полная функциональность
по чтению и модификации, но требуется некоторое знание
представления изображений в компьютере.

#### Django

Самый известный (впрочем, уже не самый популярный) веб-фреймворк, то есть комплект разнообразных модулей и утилит
для огранизации собственных сайтов. Изучение Django требует ещё больше времени, чем изучение Python &mdash; говорят, что
 Django &mdash; это практически свой надъязык, и уж точно свой "мирок" внутри мира Python.
 
#### Прочие пакеты

И конечно же, вы найдёте разнообразные пакеты для работы с базами данных, веб- и не вебсерверами, конкретными сайтами
(Twitter, VK, Facebook), всяческими форматами файлов; даже игры, утилиты и ещё бог знает что можно установить из пакетов.

К сожалению, для очень многих из них требуется порой знаний даже больше, чем для изучения языка Python. 
Но именно благодаря Python мы легко можем связывать разные компоненты в своих программах. Чем проще сам язык, 
тем больше он позволяет сфокусироваться на цели, не отвлекаясь на решение мелких технических задач.  

## Резюме

Мы сделали ещё один важный шаг в изучении Python &mdash; познакомились с модулями и пакетами, 
научились устанавливать пакеты и виртуальные окружения, импортировать и создавать модули, немного заглянули в интерфейсы
некоторых стандартных модулей.

## Задания

[Следующая лекция](./lecture_11.md) [Оглавление](./README.md) [Предыдущая лекция](./lecture_09.md) 
