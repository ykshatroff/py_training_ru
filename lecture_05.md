Лекция 5. Контейнеры. Оператор членства `in`. Циклы for. Строки (продолжение).  
=========

### Значки, используемые в тексте

* :clock2: &mdash; отмечает, что высказывание не совсем верно, но будет уточнено позднее.
* :star: &mdash; выделяет определение нового понятия.
* :exclamation: &mdash; привлекает внимание к высказыванию.
* :point_up: &mdash; указывает на небольшое отступление от темы или уточнение.
* :bulb: &mdash; индикатор традиций и договорённостей. 
* :warning: &mdash; требуется осторожность: возможно, сложное высказывание.  

### Повторение терминов из четвёртой лекции

* *Утверждение (цикл) `while`* &mdash; утверждение, указывающее интерпретатору на необходимость выполнения содержащегося
  в нём блока кода циклически (повторяя) до тех пор, *пока* выполняется его условие.
* *Объекты `True` и `False`*  &mdash; объекты булевского типа, отражающие состояние логического выражения 
  "Истинно" или "Ложно" и имеющие целочисленные эквиваленты, равные соответственно 1 и 0.
* *Логические операторы `and`, `or`, `not`*  &mdash; операторы, позволяющие комбинировать несколько простых условий
  в сложные выражения.
* *Строки* &mdash; тип данных, позволяющий оперировать с любыми символами, в частности, текстом.


## Контейнерные типы данных

До сих пор нам приходилось работать с простыми, "плоскими" (или скалярными) данными: числами, объектами "Истина"/"Ложь",
 объектом "Ничто". Строки, в некотором отношении, тоже можно отнести к плоским данным, хотя они по сути представляют собой
 упорядоченный набор символов или текст, который, с точки зрения читателя, может содержать "подстроки" -- в частности,
  буква "я" является как самостоятельным словом, так и подстрокой слова "яблоко". Вот эта особенность -- способность
объекта данных содержать в себе другие объекты -- и есть ключевое свойство контейнера.

:star: Контейнер данных -- объект, содержащий в себе другие объекты данных (элементы).

(Может возникнуть вопрос: является ли контейнером переменная? Нет, переменная -- это лишь временное "имя" объекта. Какой объект
скрыт за этим именем, скалярного или контейнерного типа -- определяется автором программы, но собственно переменная,
как мы знаем, в Python не имеет типа и поэтому не может быть контейнером.)

Строковый тип данных, в самом деле, является контейнерным типом. 

### Длина (размер) контейнера

У всех контейнеров в Python есть свойство "длины", или размера. Длина -- количество элементов в контейнере -- может быть получена
применением встроенной функции `len()`:

```python
# coding: utf-8
print len("яблоко")  # 6
print len("яблоко"[0])  # 1
print len("")  # 0
```
В третьей строке мы видим строку без каких-либо символов с длиной, равной нулю:

:star: *Пустая строка* -- строка нулевой длины, не содержащая ни одного символа. Её, как и все строки,
 можно записывать как `""`, так и `''` и с использованием тройных кавычек.


## Использование строк  как контейнеров

Главные свойства строк как контейнеров применительно к их элементам:
  
* упорядоченность: порядок элементов (символов) в строке строго определён и каждый элемент имеет свой порядковый номер (индекс); 
* однородность: все элементы строки являются также объектами типа строка;
* неуникальность: элементы строки могут повторяться любое число раз.

### Индексы

Свойства -- это отлично, но как пользоваться контейнерами? В Python существует специальная операция -- 
получение элемента контейнера по индексу :clock:. 
Она записывается как следующий за объектом контейнера индекс элемента в квадратных скобках:
  
```python
print "apple"[0]  # a
print "apple"[4]  # e 
```

:exclamation: Необходимо учесть, что в Python отсчёт индексов начинается с нуля. Это обусловлено физическим расположением
элементов в памяти: первый элемент контейнера имеет тот же адрес в памяти, что и сам контейнер (то есть, смещение равно нулю),
 второй элемент находится по смещению 1, и т.п. 
 
Каждый элемент строки -- также строка, состоящая из одного элемента, самого себя. 

Если попытаться взять элемент контейнера по индексу, превышающему его длину, то мы получим ошибку `IndexError`:

```python
print "apple"[7]  # IndexError
```

Впрочем, ту же ошибку мы получим и при обращении к индексу, *равному* длине: последний допустимый индекс равен "длине - 1",
так как отсчёт ведётся с нуля.

Чтобы получить последний элемент строки, не зная её длины, нам, таким образом, пришлось бы написать:

```python
x = "apple"
print x[len(x)-1] 
```
К счастью, в Python мы избавлены от необходимости самоповтора благодаря *отрицательным индексам*: 
начиная с `-1` и далее от нуля, индексы считаются с последнего элемента контейнера 
(в данном случае, с буквы `"e"` в слове `"apple"`), то есть отсчёт фактически эквивалентен 
арифметической сумме длины `len(x)` и индекса `-1`:  
```python
x = "apple"
print x[len(x)-1] == x[-1]  # True 
print x[len(x)-2] == x[-2]  # True
```

### Срезы (slice)

Но даже в таких операциях не сильно много толку. Например, в слове "яблоко" содержится слово "блок", и 
мы можем получить в Python эту подстроку, используя оператор "срез" (slice). 

:star: Срез -- это оператор, который формирует подмножество
 элементов контейнера "между двумя индексами", начиная от одного индекса и заканчивая вторым.
 
Он записывается как два индекса
  в квадратных скобках, разделённые двоеточием, при этом как первый, так и второй индексы можно опустить, чтобы
  вместо них использовать соответственно начало или конец строки:

```python
# coding: utf-8
print "яблоко"[1:5]  # блок
print "яблоко"[3:]  # око
print "яблоко"[-2:-1]  # к
print "яблоко"[:5]  # яблок
print "яблоко"[:-1]  # яблок
print "яблоко"[:]  # яблоко
```

:exclamation: Обратите внимание, что элемент с номером, равным второму индексу, если он указан, *не включается* в срез.

Как и в операции взятия элемента по индексу, в срезе можно использовать отрицательные индексы с тем же смыслом.

## Операторы членства (`in`)

Также в Python есть возможность проверить, содержится ли одна строка в другой. Это делается с использованием оператора
членства (элемент -- член множества) `in`:

:star: *Оператор членства* `a in b` возвращает булево значение `True`, если в контейнере `b` есть элемент `a`, и `False`
 в противном случае.
 
```python
print "a" in "apple"  # True
print "apple" in "apple"  # True
print "pp" in "apple"  # True
print "b" in "apple"  # False
```

При этом, :clock: для строк (и только для строк) оператор членства работает как с отдельными символами, так и с
подстроками. Исходя из этого, любая строка является "членом" самой себя, а пустая строка является "членом" любой строки. 

Существует и противоположный оператор `not in`: `a not in b`, который эквивалентен `not (a in b)`, но для лучшей
 читаемости рекомендуется именно `not in`.
 
## Списки
 
Можно рассматривать строку как упорядоченное множество единичных неуникальных элементов, которое во многих языках 
программирования называется "массив". То есть строка -- массив символов. В терминологии Python, массив называется списком
и отличается от строки прежде всего тем, что у него нет свойства однородности: то есть, элементом списка может быть
абсолютно любой объект.

:star: *Список* -- это упорядоченное множество неуникальных объектов любых типов данных.

В состав списка может входить и число, и строка, и объекты `True`, `False` и `None`, и конечно же сами списки и что угодно ещё
(даже функции: :clock: об этом мы ещё узнаем).

Над списком определены упомянутые нами операции взятия элемента по индексу, среза, проверки членства элемента 
(с той разницей, что каждый элемент рассматривается только поодиночке: членство списка в списке означает, что *объект списка
входит в список-контейнер как единый элемент*, но элементы списка-члена *не являются* сами элементами списка-контейнера).

Список можно объявить в Python с помощью литерала `[]` : квадратные скобки, между которыми через запятую перечислены
элементы, входящие в список (можно объявить и пустой список, без элементов).

```python
```
