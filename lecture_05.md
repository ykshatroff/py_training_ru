Лекция 5. Утверждение `assert`. Контейнеры. Оператор членства `in`. Циклы `for`. Строки (продолжение).  
=========

### Значки, используемые в тексте

* :clock2: &mdash; отмечает, что высказывание не совсем верно, но будет уточнено позднее.
* :star: &mdash; выделяет определение нового понятия.
* :exclamation: &mdash; привлекает внимание к высказыванию.
* :point_up: &mdash; указывает на небольшое отступление от темы или уточнение.
* :bulb: &mdash; индикатор традиций и договорённостей. 
* :warning: &mdash; требуется осторожность: возможно, сложное высказывание.  

### Повторение терминов из четвёртой лекции

* *Утверждение (цикл) `while`* &mdash; утверждение, указывающее интерпретатору на необходимость выполнения содержащегося
  в нём блока кода циклически (повторяя) до тех пор, *пока* выполняется его условие.
* *Объекты `True` и `False`*  &mdash; объекты булевского типа, отражающие состояние логического выражения 
  "Истинно" или "Ложно" и имеющие целочисленные эквиваленты, равные соответственно 1 и 0.
* *Логические операторы `and`, `or`, `not`*  &mdash; операторы, позволяющие комбинировать несколько простых условий
  в сложные выражения.
* *Строки* &mdash; тип данных, позволяющий оперировать с любыми символами, в частности, текстом.


## Утверждение `assert`

Для того, чтобы убедиться, что результат выражения именно такой, как мы предполагаем, мы ранее использовали возможность 
вывести результат на экран с помощью утверждения `print`. Однако это, во-первых, недопустимо в программах, 
работающих в  промышленном режиме, а во-вторых, иногда представление разных сущностей  на экране одинаково, например:
 
```python
print 1  # 1
print "1"  # 1
```
Хотя один объект -- число, второй -- строка, выглядят они на экране одинаково. При этом для программы они совершенно
разные по смыслу, и если попытаться например сложить `1 + "1"`, мы получим ошибку `TypeError: unsupported operand type...`

Чтобы избежать необходимости проверять глазами вывод и в то же время быть уверенным в корректности программы, существует
утверждение `assert`, состоящее из ключевого слова `assert` и идущего за ним выражения, и опционально комментария.

Если логический эквивалент выражения -- "истинно" (`True`), то утверждение просто игнорируется. Если же "ложно" (`False`),
то возникает ошибка `AssertionError`, и в её тексте будет указанный
комментарий.
```python
assert True  
assert 1 == 1  
assert False  # -> AssertionError
assert False, "Comment"  # -> AssertionError: Comment
```

Далее мы будем использовать это утверждение в наших примерах.

## Контейнерные типы данных

До сих пор нам приходилось работать с простыми, "плоскими" (или скалярными) данными: числами, объектами "Истина"/"Ложь",
 объектом "Ничто". Строки, в некотором отношении, тоже можно отнести к плоским данным, хотя они по сути представляют собой
 упорядоченный набор символов или текст, который, с точки зрения читателя, может содержать "подстроки" -- в частности,
  буква "я" является как самостоятельным словом, так и подстрокой слова "яблоко". Вот эта особенность -- способность
объекта данных содержать в себе другие объекты -- и есть ключевое свойство контейнера.

:star: Контейнер данных -- объект, содержащий в себе другие объекты данных (элементы).

(Может возникнуть вопрос: является ли контейнером переменная? Нет, переменная -- это лишь временное "имя" объекта. Какой объект
скрыт за этим именем, скалярного или контейнерного типа -- определяется автором программы, но собственно переменная,
как мы знаем, в Python не имеет типа и поэтому не может быть контейнером.)

Строковый тип данных, в самом деле, является контейнерным типом. 

### Длина (размер) контейнера

У всех контейнеров в Python есть свойство "длины", или размера. Длина -- количество элементов в контейнере -- может быть получена
применением встроенной функции `len()`:

```python
# coding: utf-8
assert len("яблоко") == 6
assert len("яблоко"[0]) == 1
assert len("") == 0
```
В третьей строке мы видим строку без каких-либо символов с длиной, равной нулю:

:star: *Пустая строка* -- строка нулевой длины, не содержащая ни одного символа. Её, как и все строки,
 можно записывать как `""`, так и `''` и с использованием тройных кавычек.
 
:exclamation: Все контейнеры, в том числе и строки, имеют следующее свойство: в логическом контексте
 контейнер (строка) с нулевой длиной эквивалентен значению `False`, с ненулевой длиной -- `True`.
 
```python
print bool("asd")  # True
print bool("")  # False
print bool("0")  # True
print bool("False")  # True, потому что "False" - это не объект False, а строка!
```


## Использование строк  как контейнеров

Главные свойства строк как контейнеров применительно к их элементам:
  
* упорядоченность: порядок элементов (символов) в строке строго определён и каждый элемент имеет свой порядковый номер (индекс); 
* однородность: все элементы строки являются также объектами типа строка;
* неуникальность: элементы строки могут повторяться любое число раз.

### Индексы

Свойства -- это отлично, но как пользоваться контейнерами? В Python существует специальная операция -- 
получение элемента контейнера по индексу :clock:. 
Она записывается как следующий за объектом контейнера индекс элемента в квадратных скобках:
  
```python
assert "apple"[0] == "a"
assert "apple"[4] == "e" 
```

:exclamation: Необходимо учесть, что в Python отсчёт индексов начинается с нуля. Это обусловлено физическим расположением
элементов в памяти: первый элемент контейнера имеет тот же адрес в памяти, что и сам контейнер (то есть, смещение равно нулю),
 второй элемент находится по смещению 1, и т.п. 
 
Каждый элемент строки -- также строка, состоящая из одного элемента, самого себя. 

Если попытаться взять элемент контейнера по индексу, превышающему его длину, то мы получим ошибку `IndexError`:

```python
print "apple"[7]  # IndexError
```

Впрочем, ту же ошибку мы получим и при обращении к индексу, *равному* длине: последний допустимый индекс равен "длине - 1",
так как отсчёт ведётся с нуля.

Чтобы получить последний элемент строки, не зная её длины, нам, таким образом, пришлось бы написать:

```python
x = "apple"
assert x[len(x)-1] == "e" 
```
К счастью, в Python мы избавлены от необходимости самоповтора благодаря *отрицательным индексам*: 
начиная с `-1` и далее от нуля, индексы считаются с последнего элемента контейнера 
(в данном случае, с буквы `"e"` в слове `"apple"`), то есть отсчёт фактически эквивалентен 
арифметической сумме длины `len(x)` и индекса `-1`:  
```python
x = "apple"
assert x[len(x)-1] == x[-1]
assert x[len(x)-2] == x[-2]
```

### Срезы (slice)

Но даже в таких операциях не сильно много толку. Например, в слове "яблоко" содержится слово "блок", и 
мы можем получить в Python эту подстроку, используя оператор "срез" (slice). 

:star: Срез -- это оператор, который формирует подмножество
 элементов контейнера "между двумя индексами", начиная от одного индекса и заканчивая вторым.
 
Он записывается как два индекса
  в квадратных скобках, разделённые двоеточием, при этом как первый, так и второй индексы можно опустить, чтобы
  вместо них использовать соответственно начало или конец строки:

```python
# coding: utf-8
print "яблоко"[1:5]  # блок
print "яблоко"[3:]  # око
print "яблоко"[-2:-1]  # к
print "яблоко"[:5]  # яблок
print "яблоко"[:-1]  # яблок
print "яблоко"[:]  # яблоко
```

:exclamation: Обратите внимание, что элемент с номером, равным второму индексу, если он указан, *не включается* в срез.

Как и в операции взятия элемента по индексу, в срезе можно использовать отрицательные индексы с тем же смыслом.

## Операторы членства (`in`)

Также в Python есть возможность проверить, содержится ли одна строка в другой. Это делается с использованием оператора
членства (элемент -- член множества) `in`:

:star: *Оператор членства* `a in b` возвращает булево значение `True`, если в контейнере `b` есть элемент `a`, и `False`
 в противном случае.
 
```python
print "a" in "apple"  # True
assert "apple" in "apple"
assert "pp" in "apple"
assert not ("b" in "apple")
```

При этом, :clock: для строк (и только для строк) оператор членства работает как с отдельными символами, так и с
подстроками. Исходя из этого, любая строка является "членом" самой себя, а пустая строка является "членом" любой строки. 

Существует и противоположный оператор `not in`: `a not in b`, который эквивалентен `not (a in b)`, но для лучшей
 читаемости рекомендуется именно `not in`.
 
## Операция сложения строк

В прошлой лекции мы уже рассматривали одну операцию над строками -- это интерполяция с помощью оператора `%`. 
Этой операцией мы можем создавать новые строки на основе других строк. Сам оператор `%` выполняет
разные действия с данными в зависимости от их типа: с числами -- остаток от деления по модулю, со строками -- интерполяцию.
В Python это совершенно обыденное явление. Также и оператор `+` складывает числа, и он же "складывает" строки.
Одна строка "плюс" другая -- это новая строка, состоящая из всех символов первой и сразу же за ними -- всех символов
второй с сохранением порядка.

```python
print "a" + "pple"  # apple
print "apple" + "plum"  # appleplum
print len("apple"), len("plum"), len("apple" + "plum")  # 5 4 9
```

Для переменных, указывающих на строку, допустимо использовать оператор сложения "на месте" `+=`:
```python
x = "a"
assert x + "pple" == "apple"
x += "pple"
assert x == "apple"
```
Операция сложения строк называется также *конкатенацией*.

 
## Списки
 
Можно рассматривать строку как упорядоченное множество единичных неуникальных элементов, которое во многих языках 
программирования называется "массив". То есть строка -- массив символов. В терминологии Python, массив называется списком
и отличается от строки прежде всего тем, что у него нет свойства однородности: то есть, элементом списка может быть
абсолютно любой объект.

:star: *Список* -- это упорядоченное множество неуникальных объектов любых типов данных.

В состав списка может входить и число, и строка, и объекты `True`, `False` и `None`, и конечно же сами списки и что угодно ещё
(даже функции: :clock: об этом мы ещё узнаем).

Список можно объявить в Python с помощью литерала `[]` : квадратные скобки, между которыми через запятую перечислены
элементы, входящие в список. Элемент списка может определяться любым выражением: выражение вычислится в момент
объявления списка, и элемент получит его значение. Можно объявить и пустой список, без элементов.

```python
# coding: utf-8
[1, 2, 3, 4]  # список из чисел
[False, True]  # список из булевых объектов 
["", 0, 0.0, False, [], None]  # список из объектов разных типов, которые в логическом контексте эквивалентны False

x = "a"
y = "1"
[x, int(y), input("Введите третий элемент:")]  # список, в котором данные задаются из переменных или из функций 
```

Над списком определены упомянутые нами операции взятия элемента по индексу, среза, проверки членства элемента 
(с той разницей, что каждый элемент рассматривается только поодиночке: членство списка в списке означает, что *объект списка
входит в список-контейнер как единый элемент*, но элементы списка-члена *не являются* сами элементами списка-контейнера).

Списки, как и строки, можно складывать, в результате получится новый список, состоящий из элементов первого и второго
списков с сохранением порядка.

## Изменяемые и неизменяемые объекты

Однако операция присваивания "на месте" со списком работает несколько по-иному. Если в результате применения операции
к перменной, содержащей строку, формировалась *новая строка*, дополненная слагаемым аргументом, то список *модифицируется*
непосредственно, то есть новый объект списка не создаётся, а значения второго аргумента просто дописываются в этот список.

Это второе ключевое отличие списков от строк: *изменяемость*. До списков мы имели дело только с *неизменяемыми*
 типами данных: скажем, оператор сложения "на месте" над числами просто записывает в переменную новое число.
 
Какие последствия это имеет? Продемонстрируем на следующем примере:
 
```python
x = [1, 3, 5] 
y = x
x += [7, 9]
print x, y  # [1, 3, 5, 7, 9] [1, 3, 5, 7, 9]
```

мы увидели, что *обе* переменных-списка стали содержать одинаковые элементы. На самом деле, это и есть *один и тот же*
объект-список, просто у него два разных *имени*.

Концепция *изменяемости* в Python имеет крайне важное значение. Практический смысл этого понятия пока нам не так очевиден, но
уже очень скоро мы будем иметь с ним дело. 

## Кортежи (tuple)

У списков есть и неизменяемый аналог -- кортежи (`tuple`). Они вводятся литералами `()` (круглые скобки), внутри
которых, как и в списках, через запятую перечисляются содержащиеся данные. 

```python
(1, 3, 5) 
("", False, None)
```

:exclamation: Для того, чтобы отличить кортеж с одним элементом от просто выражения в скобках, после первого и единственного
элемента кортежа ставится запятая; таким образом, *любое выражение* с примыкающей запятой, заключённое в скобки --
 это кортеж из одного элемента:

```python
print (1)  # выражение, значение которого - число 1
print (1, )  # кортеж с единственным элементом 1
print (input())  # выражение
print (input(), )  # кортеж
```

## Практическое использование кортежей и списков

Одно из самых частых использований кортежей -- в операциях интерполяции строк. Если левый аргумент-строка
содержит несколько "плейсхолдеров" вида `%s`, а правый аргумент является кортежем, то все эти плейсхолдеры по порядку
заменяются на элементы кортежа:

```python
print "This is a %s number %s" % ("test", 1)  # This is a test number 1 
```
Если количество плейсхолдеров не совпадает с количеством элементов в кортеже, будет ошибка `TypeError`.

Если в строке ровно 1 плейсхолдер, то вторым аргументом можно указать как непосредственный объект, так и кортеж из одного
 объекта, и это единственно возможный вариант, если таким объектом является собственно кортеж: 
 
```python
print "This is a tuple: %s " % (("test", 1), )  # This is a tuple: (test, 1) 
print "This is an ERROR: %s " % ("test", 1)  # TypeError: ...
```

Литералы кортежей можно спутать с аргументами функций,
но обычно они появляются в разных контекстах. Впрочем, аргументом функции может быть и объект типа "кортеж", в таком
случае приходится немного усложнять запись вызова функции. 

Вспомним уже рассмотренные нами в третьей лекции функции `min()`, `max()`: мы говорили, что они принимают от двух и более
простых (скалярных) аргументов. Так вот, если передать этим функциям *один* аргумент, которым будет *кортеж или список*,
то они вычислят минимум или максимум из его элементов. И обратите внимание на то, как записывается вызов функции
с аргументом-литералом кортежа.

```python
list_of_numbers = [1, 3, 7, 4, 5]
assert max(list_of_numbers) == 7
tuple_of_numbers = (1, 3, 7, 4, 5)
assert max(tuple_of_numbers) == 7
assert max((1, 3, 7, 4, 5)) == 7
```
Для корректной передачи литерала кортежа в качестве аргумента, мы пишем две пары скобок: одни обозначают вызов функции,
вторые -- объявление литерала. Всё логично.

## Цикл `for`

Есть ещё одно очень важное свойство, общее для (практически) всех контейнеров в Python: *итерируемость*.
В прошлой лекции мы упоминали, что один проход выполнения цикла `while` называется итерацией. Применительно к контейнерам,
можно повторить одно и то же действие (блок кода) циклически к каждому элементу, и в этом случае 
итерация -- это выполнение данного действия над одним элементом, а итерируемость объекта -- возможность выполнять повторяющееся
 действие над элементами объекта.
 
В псевдокоде мы можем выразить подобное так:
 
    ДЛЯ каждого элемента ИЗ контейнера:
        БЛОК_КОДА
 
В Python возможность пройти по элементам контейнера с выполнением над ними повторяющегося действия реализуется 
используя конструкцию `for`:

    for ELEMENT in CONTAINER:
        БЛОК_КОДА

В данном случае ELEMENT -- это некая временная переменная, принимающая по очереди значения каждого элемента контейнера 
(списка, кортежа, строки), указанного в CONTAINER. Эта переменная доступна в БЛОК_КОДА как обычная переменная, 
но в каждой итерации она имеет разное значение. 

Поясним на простом примере:

```python
for x in [1, 2, 3]:
    print x
```
Данный цикл выведет последовательно числа 1, 2, 3; `х` будет принимать последовательно значения 1, 2, 3.

Точно так же можно *проитерировать* кортежи -- и строки, которые будут рассматриваться как набор символов:

```python
for x in "apple":
    print x
```
Этот код выведет по одной букве в строке: "a", "p", "p", "l", "e" .
 
Переменную цикла (в данном случае это `x`) можно менять в теле цикла, но перед каждой итерацией ей будет присвоено
следующее значение, за исключением последней итерации, после которой она сохранит своё значение и останется с ним
и после выхода из цикла.

## Ввод литералов с помощью `input()`

Функция `input()` оказывается не простая: с её помощью можно вводить любые литералы, в частности списки, кортежи и строки.
Только одно условие: они должны быть записаны синтаксически корректно.

```python
x = input('Input "apple": ')  # введём "apple" - именно так, с кавычками
assert x == "apple"
```
Если ввести "apple" без кавычек, функция `input()` будет рассматривать это слово как идентификатор переменной, которая
не объявлена и вызовет ошибку NameError.

## Конвертация типов контейнеров

В прошлой лекции мы встретили функции-конверторы типов данных `bool()`, `int()` и т.п. Объекты-контейнеры тоже
можно конвертировать между собой, хотя и есть некоторые моменты, заслуживающие отдельного внимания.

Для конвертации объекта в список существует функция `list()`, принимающая один аргумент-контейнер. 
Без аргументов она просто вернёт пустой список, то есть `list() == []`.
Если аргумент -- кортеж, то будет создан список с теми же объектами и в том же порядке, как в кортеже. Если объект -- строка,
 то строка будет разбита по символам и список будет состоять из элементов-однобуквенных строк. Если объект -- список,
 то будет создан список -- полная копия оригинального (часто эту функцию и используют с этой целью, ведь, как мы помним,
 список изменяемый, и чтобы сохранять оригинальное значение, создаются копии).
 
```python
list((1, 2, 3))  # [1, 2, 3]
list([1, 2, 3])  # [1, 2, 3]
list("asd")  # ["a", "s", "d"]
```
 
Почти так же работает и функция `tuple()` -- создаёт кортеж с элементами из списка или кортежа, или с односимвольными строками
из строки. Она всегда создаёт копию кортежа, так как кортеж неизменяем.

Функция `str()` же, в отличие от предыдущих, просто превращает объект в строку, подходящую для вывода в консоль,
 максимально напоминающую литерал:

```python
assert str([1, 2, 3]) == "[1, 2, 3]"  
assert str((1, 2, 3)) == "(1, 2, 3)"  
```

Из строки функция `str()` также сделает копию строки.

## Функции `ord()` и `chr()`

