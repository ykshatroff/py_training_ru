Лекция 5. Утверждение `assert`.  Строки (продолжение). Контейнеры. Оператор членства `in`. Циклы `for`.  
=========

### Значки, используемые в тексте

* :clock2: &mdash; отмечает, что высказывание не совсем верно, но будет уточнено позднее.
* :star: &mdash; выделяет определение нового понятия.
* :exclamation: &mdash; привлекает внимание к высказыванию.
* :point_up: &mdash; указывает на небольшое отступление от темы или уточнение.
* :bulb: &mdash; индикатор традиций и договорённостей. 
* :warning: &mdash; требуется осторожность: возможно, сложное высказывание.  

### Повторение терминов из четвёртой лекции

* *Утверждение (цикл) `while`* &mdash; утверждение, указывающее интерпретатору на необходимость выполнения содержащегося
  в нём блока кода циклически (повторяя) до тех пор, *пока* выполняется его условие.
* *Объекты `True` и `False`*  &mdash; объекты булевского типа, отражающие состояние логического выражения 
  "Истинно" или "Ложно" и имеющие целочисленные эквиваленты, равные соответственно 1 и 0.
* *Логические операторы `and`, `or`, `not`*  &mdash; операторы, позволяющие комбинировать несколько простых условий
  в сложные выражения.
* *Строки* &mdash; тип данных, позволяющий оперировать с любыми символами, в частности, текстом.


## Утверждение `assert`

Для того, чтобы убедиться, что результат выражения именно такой, как мы предполагаем, мы ранее использовали возможность 
вывести результат на экран с помощью утверждения `print`. Однако это, во-первых, недопустимо в программах, 
работающих в  промышленном режиме, а во-вторых, иногда представление разных сущностей  на экране одинаково, например:
 
```python
print 1  # 1
print "1"  # 1
```
Хотя один объект &mdash; число, второй &mdash; строка, выглядят они на экране одинаково. При этом для программы они совершенно
разные по смыслу, и если попытаться например сложить `1 + "1"`, мы получим ошибку `TypeError: unsupported operand type...`

Чтобы избежать необходимости проверять глазами вывод и в то же время быть уверенным в корректности программы, существует
утверждение `assert`, состоящее из ключевого слова `assert` и идущего за ним выражения, и опционально комментария.

Если логический эквивалент выражения &mdash; "истинно" (`True`), то утверждение просто игнорируется. Если же "ложно" (`False`),
то возникает ошибка `AssertionError`, и в её тексте будет указанный
комментарий.
```python
assert True  
assert 1 == 1  
assert 0 != 1  
assert not False
assert False  # здесь программа закончится с ошибкой AssertionError
assert False, "Comment"  # здесь программа закончится с ошибкой: AssertionError: Comment
```

Далее мы будем использовать это утверждение в наших примерах.

## Контейнерные типы данных

До сих пор нам приходилось работать с простыми, "плоскими" (или скалярными) данными: числами, объектами "Истина"/"Ложь",
 объектом "Ничто". Строки, в некотором отношении, тоже можно отнести к плоским данным, хотя они по сути представляют собой
 упорядоченный набор символов или текст, который, с точки зрения читателя, может содержать "подстроки" &mdash; в частности,
  буква "я" является как самостоятельным словом, так и подстрокой слова "яблоко". Вот эта особенность &mdash; способность
объекта данных содержать в себе другие объекты &mdash; и есть ключевое свойство контейнера.

:star: Контейнер данных &mdash; объект, содержащий в себе другие объекты данных (элементы).

(Может возникнуть вопрос: является ли контейнером переменная? Нет, переменная &mdash; это лишь временное "имя" объекта. Какой объект
скрыт за этим именем, скалярного или контейнерного типа &mdash; определяется автором программы, но собственно переменная,
как мы знаем, в Python не имеет типа и поэтому не может быть контейнером.)

Строковый тип данных, в самом деле, является контейнерным типом. 

### Длина (размер) контейнера

У всех контейнеров в Python есть свойство "длины", или размера. Длина &mdash; количество элементов в контейнере &mdash; может быть получена
применением встроенной функции `len()`:

```python
assert len("apple") == 5
assert len("apple"[0]) == 1
assert len("") == 0
```
В третьей строке мы видим строку, не содержащую каких-либо символов между кавычками, с длиной, равной нулю:

:star: *Пустая строка* &mdash; строка нулевой длины, не содержащая ни одного символа. Её, как и все строки,
 можно записывать как `""`, так и `''` и с использованием тройных кавычек.
 
:exclamation: Все контейнеры, в том числе и строки, имеют следующее свойство: в логическом контексте
 контейнер (строка) с нулевой длиной эквивалентен значению `False`, с ненулевой длиной &mdash; `True`.
 
```python
print bool("asd")  # True
print bool("")  # False
print bool("0")  # True
print bool("False")  # True, потому что "False" - это не объект False, а строка!
```

## Использование строк  как контейнеров

Главные свойства строк как контейнеров применительно к их элементам:
  
* упорядоченность: порядок элементов (символов) в строке строго определён и каждый элемент имеет свой порядковый номер (индекс); 
* однородность: все элементы строки являются также объектами типа строка;
* неуникальность: элементы строки могут повторяться любое число раз.

### Индексы

Свойства &mdash; это отлично, но как пользоваться контейнерами? В Python существует специальная операция &mdash; 
получение элемента контейнера по индексу :clock:. 
Она записывается как следующий за объектом контейнера индекс элемента в квадратных скобках:
  
```python
assert "apple"[0] == "a"
assert "apple"[4] == "e" 
```

:exclamation: Необходимо учесть, что в Python отсчёт индексов начинается с нуля. Это обусловлено физическим расположением
элементов в памяти: первый элемент контейнера имеет тот же адрес в памяти, что и сам контейнер (то есть, смещение равно нулю),
 второй элемент находится по смещению 1, и т.п. 
 
Каждый элемент строки &mdash; также строка, состоящая из одного элемента, самого себя. 

Если попытаться взять элемент контейнера по индексу, превышающему его длину, то мы получим ошибку `IndexError`:

```python
print "apple"[7]  # IndexError
```

Впрочем, ту же ошибку мы получим и при обращении к индексу, *равному* длине: последний допустимый индекс равен "длине - 1",
так как отсчёт ведётся с нуля.

Чтобы получить последний элемент строки, не зная её длины, нам, таким образом, пришлось бы написать:

```python
x = "apple"
assert x[len(x)-1] == "e" 
```
К счастью, в Python мы избавлены от необходимости самоповтора благодаря *отрицательным индексам*: 
начиная с `-1` и далее от нуля, индексы считаются с последнего элемента контейнера 
(в данном случае, с буквы `"e"` в слове `"apple"`), то есть отсчёт фактически эквивалентен 
арифметической сумме длины `len(x)` и индекса `-1`:  
```python
x = "apple"
assert x[len(x)-1] == x[-1]
assert x[len(x)-2] == x[-2]
```

### Срезы (slice)

Но даже в таких операциях не сильно много толку. Например, в слове "яблоко" содержится слово "блок", и 
мы можем получить в Python эту подстроку, используя оператор "срез" (slice). 

:star: Срез &mdash; это оператор, который формирует подмножество
 элементов контейнера "между двумя индексами", начиная от одного индекса и заканчивая вторым.
 
Он записывается как два индекса
  в квадратных скобках, разделённые двоеточием, при этом как первый, так и второй индексы можно опустить, чтобы
  вместо них использовать соответственно начало или конец строки:

```python
assert "thing"[1:4] == "hin"
assert "thing"[2:] == "ing"
assert "thing"[-3:-1] == "in"
assert "thing"[:4]  == "thin"
assert "thing"[:-1] == "thin"
assert "thing"[:] == "thing"
```

:exclamation: Обратите внимание, что элемент с номером, равным второму индексу, если он указан, *не включается* в срез.

Как и в операции взятия элемента по индексу, в срезе можно использовать отрицательные индексы с тем же смыслом.

## Операторы членства (`in`)

Также в Python есть возможность проверить, содержится ли одна строка в другой. Это делается с использованием оператора
членства (элемент &mdash; член множества) `in`:

:star: *Оператор членства* `a in b` возвращает булево значение `True`, если в контейнере `b` есть элемент `a`, и `False`
 в противном случае.
 
```python
print "a" in "apple"  # True
assert "apple" in "apple"
assert "pp" in "apple"
assert not ("b" in "apple")
```

При этом, :clock: для строк (и только для строк) оператор членства работает как с отдельными символами, так и с
подстроками. Исходя из этого, любая строка является "членом" самой себя, а пустая строка является "членом" любой строки. 

Существует и противоположный оператор `not in`: `a not in b`, который эквивалентен `not (a in b)`, но для лучшей
 читаемости рекомендуется именно `not in`.
 
## Операция сложения строк

В прошлой лекции мы уже рассматривали одну операцию над строками &mdash; это интерполяция с помощью оператора `%`. 
Этой операцией мы можем создавать новые строки на основе других строк. Сам оператор `%` выполняет
разные действия с данными в зависимости от их типа: с числами &mdash; остаток от деления по модулю, со строками &mdash; интерполяцию.
В Python это совершенно обыденное явление. Также и оператор `+` складывает числа, и он же "складывает" строки.
Одна строка "плюс" другая &mdash; это новая строка, состоящая из всех символов первой и сразу же за ними &mdash; всех символов
второй с сохранением порядка.

```python
print "a" + "pple"  # apple
print "apple" + "plum"  # appleplum
print len("apple"), len("plum"), len("apple" + "plum")  # 5 4 9
```

Для переменных, указывающих на строку, допустимо использовать оператор сложения "на месте" `+=`:
```python
x = "a"
assert x + "pple" == "apple"
x += "pple"
assert x == "apple"
```
Операция сложения строк называется также *конкатенацией*.

 
## Списки
 
Можно рассматривать строку как упорядоченное множество единичных неуникальных элементов, которое во многих языках 
программирования называется "массив". То есть строка &mdash; массив символов. В терминологии Python, массив называется списком
и отличается от строки прежде всего тем, что у него нет свойства однородности: то есть, элементом списка может быть
абсолютно любой объект.

:star: *Список* &mdash; это упорядоченное множество неуникальных объектов любых типов данных.

В состав списка может входить и число, и строка, и объекты `True`, `False` и `None`, и конечно же сами списки и что угодно ещё
(даже функции: :clock: об этом мы ещё узнаем).

Список можно объявить в Python с помощью литерала `[]` : квадратные скобки, между которыми через запятую перечислены
элементы, входящие в список. Элемент списка может определяться любым выражением: выражение вычислится в момент
объявления списка, и элемент получит его значение. Можно объявить и пустой список, без элементов.

```python
# coding: utf-8
[1, 2, 3, 4]  # список из чисел
[False, True]  # список из булевых объектов 
["", 0, 0.0, False, [], None]  # список из объектов разных типов, которые в логическом контексте эквивалентны False

x = "a"
y = "1"
[x, int(y), input()]  # список, в котором данные задаются из переменных или из функций 
```

Над списком определены упомянутые нами операции взятия элемента по индексу, среза, проверки членства элемента 
(с той разницей, что каждый элемент рассматривается только поодиночке: членство списка в списке означает, что *объект списка
входит в список-контейнер как единый элемент*, но элементы списка-члена *не являются* сами элементами списка-контейнера).

Списки, как и строки, можно складывать, в результате получится новый список, состоящий из элементов первого и второго
списков с сохранением порядка.


## Цикл `for`

Есть ещё одно очень важное свойство, общее для (практически) всех контейнеров в Python: *итерируемость*.
В прошлой лекции мы упоминали, что один проход выполнения цикла `while` называется итерацией. Применительно к контейнерам,
можно повторить одно и то же действие (блок кода) циклически к каждому элементу, и в этом случае 
итерация &mdash; это выполнение данного действия над одним элементом, а итерируемость объекта &mdash; возможность выполнять повторяющееся
 действие над элементами объекта.
 
В псевдокоде мы можем выразить подобное так:
 
    ДЛЯ каждого элемента ИЗ контейнера:
        БЛОК_КОДА
 
В Python возможность пройти по элементам контейнера с выполнением над ними повторяющегося действия реализуется 
используя конструкцию `for`:

    for ELEMENT in CONTAINER:
        БЛОК_КОДА

В данном случае ELEMENT &mdash; это некая временная переменная, принимающая по очереди значения каждого элемента контейнера 
(списка, строки...), указанного в CONTAINER. Эта переменная доступна в БЛОК_КОДА как обычная переменная, 
но в каждой итерации она имеет разное значение. 

Поясним на простом примере:

```python
for x in [1, 2, 3]:
    print x
```
Данный цикл выведет последовательно числа 1, 2, 3, так как `х` будет принимать последовательно значения 1, 2, 3.

Точно так же можно *проитерировать* и строки, которые будут рассматриваться как набор символов:

```python
for x in "apple":
    print x
```
Этот код выведет по одной букве в строке: "a", "p", "p", "l", "e" .
 
Переменную цикла (в данном случае это `x`) можно менять в теле цикла, но перед каждой итерацией ей будет присвоено
следующее значение, за исключением последней итерации, после которой она сохранит своё значение и останется с ним
и после выхода из цикла.


